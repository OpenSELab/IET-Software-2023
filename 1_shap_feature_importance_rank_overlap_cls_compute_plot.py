# -*- coding: utf-8 -*-
"""1-SHAP_feature_importance_rank_overlap_cls_compute_plot

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UI1JnMcj27Xns74AbNeYZ_QusTzJvFsu
"""

import scipy.io.arff
import pandas as pd
import numpy as np
from sklearn.utils import resample # for Bootstrap sampling
import shutil
import os

from numpy import array

#Import resampling and modeling algorithms

from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier

from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import matthews_corrcoef

import warnings

warnings.filterwarnings("ignore")

# click load google drive
rootpath = "/content/drive/MyDrive/Colab Notebooks/1/"

datasets_original = "datasets-original/"
datasets_discretize = "datasets-discretize/"
datasets_log = "datasets-log/"
datasets_minmax = "datasets-min-max/"
datasets_standardize = "datasets-standardize/"

AEEEM = ["EQ"]
ReLink = ["Zxing", "Apache", "Safe"]
Promise = [ "camel-1.2", "ivy-1.1", "jedit-3.2", "log4j-1.1", "lucene-2.0", "lucene-2.2", "lucene-2.4",
        "poi-1.5", "poi-2.5", "poi-3.0", "xalan-2.5", "xalan-2.6"]

ARFF = "ARFF/"
CSV = "CSV/"

BOOTSTRAP = "BOOTSTRAP/"

CLS = [RandomForestClassifier(random_state=0),LogisticRegression(random_state=0),GaussianNB(),DecisionTreeClassifier(random_state=0),KNeighborsClassifier(),MLPClassifier(random_state=0)]

# some data sets imbanlance so we exclude it because these classifier have precision recall and f1 = 0  so we select 30-70% percent of defective

data_o_Promise = pd.DataFrame(pd.read_csv(rootpath + datasets_original + "Promise-shap-test-rank.csv"))

data_o_ReLink = pd.DataFrame(pd.read_csv(rootpath + datasets_original + "ReLink-shap-test-rank.csv"))

data_o_AEEEM = pd.DataFrame(pd.read_csv(rootpath + datasets_original + "AEEEM-shap-test-rank.csv"))

data_log_Promise = pd.DataFrame(pd.read_csv(rootpath + datasets_log + "Promise-shap-test-rank.csv"))

data_log_ReLink = pd.DataFrame(pd.read_csv(rootpath + datasets_log + "ReLink-shap-test-rank.csv"))

data_log_AEEEM = pd.DataFrame(pd.read_csv(rootpath + datasets_log + "AEEEM-shap-test-rank.csv"))


data_min_Promise = pd.DataFrame(pd.read_csv(rootpath + datasets_minmax + "Promise-shap-test-rank.csv"))

data_min_ReLink = pd.DataFrame(pd.read_csv(rootpath + datasets_minmax + "ReLink-shap-test-rank.csv"))

data_min_AEEEM = pd.DataFrame(pd.read_csv(rootpath + datasets_minmax + "AEEEM-shap-test-rank.csv"))

data_sta_Promise = pd.DataFrame(pd.read_csv(rootpath + datasets_standardize + "Promise-shap-test-rank.csv"))

data_sta_ReLink = pd.DataFrame(pd.read_csv(rootpath + datasets_standardize + "ReLink-shap-test-rank.csv"))

data_sta_AEEEM = pd.DataFrame(pd.read_csv(rootpath + datasets_standardize + "AEEEM-shap-test-rank.csv"))

print(data_o_Promise.head())
print(data_o_Promise.loc[1].values[0])
print(data_o_Promise.shape)
print(data_log_Promise.shape)
print(data_o_Promise.shape[0])
print(data_log_Promise.shape[1])
print(data_o_Promise.index)

print(data_o_Promise.shape)
print(data_o_ReLink.shape)
print(data_o_AEEEM.shape)
print(data_log_Promise.shape)
print(data_log_ReLink.shape)
print(data_log_AEEEM.shape)

O = [data_o_Promise, data_o_ReLink, data_o_AEEEM]
L = [data_log_Promise, data_log_ReLink, data_log_AEEEM]
M = [data_min_Promise, data_min_ReLink, data_min_AEEEM]
S = [data_sta_Promise, data_sta_ReLink, data_sta_AEEEM]

# 这是每个特征得分的排名  有时一行有两个排名为 1 那计算特征重复的时候 overlap-1 要么是0 要么是1 要么是 1/3？1/4？
#

# 按分类器计算特征重复 有6个分类器 每个分类器有25次实验
# overlap-1 每个分类器得到的排名为1的特征

# AEEEM 150行63列 1个数据集 每个数据集做6个分类器*25次采样=150次实验 61列属性 2列自己加的标记 63列属性
# Promise 1800行22列 12个数据集 每个数据集做6个分类器*25次采样=1800次实验
# ReLink 450行28列 3个数据集 每个数据集做6个分类器*25次采样=450次实验
# 将特征重复按分类器类型计算
# AEEEM 仅有一个 EQ 数据集 有150次实验结果 其中第一个25次是 RF 第二个25次是 LR 第三个25次是 NB 第四个25次是 DT 第五个25次是 KNN 第六个25次是 MLP
# ReLink 有 三个数据集 Zxing Apache Safe 有450次实验结果 每个数据集各150次实验 每个数据集的150次实验都按照 RF-25 LR-25 NB-25 DT-25 KNN-25 MLP-25 构成
# Promise 有 12个数据集 有1800次实验结果 每个数据集各150次实验
# 每一个数据集的第一个项目的 150次实验
# 计算 RF 的特征重复 循环从0至24 0*gap - 1*gap-1   0*gap+k  l=0
# 计算 LR 的特征重复 循环从25至49 1*gap - 2*gap-1  1*gap+k
# 计算 NB 循环从50至74 2*gap - 3*gap-1        2*gap+k
# 计算 DT 循环从75至99 3*gap - 4*gap-1        3*gap+k
# 计算 KNN 循环从100至124 4*gap - 5*gap-1       4*gap+k
# 计算 MLP 循环从125至149 5*gap - 6*gap-1       5*gap+k
# 每一个数据集的第二个项目的 150次实验
# 计算 RF 的特征重复 循环从150至174 6*gap - 7*gap-1  6*gap+k  l=1
# 计算 LR 的特征重复 循环从175至199 7*gap - 8*gap-1  7*gap+k
# 计算 NB 的特征重复 循环从200至224 8*gap - 9*gap-1  8*gap+k
# 计算 DT 的特征重复 循环从225至249 9*gap - 10*gap-1  9*gap+k
# 计算 KNN 的特征重复 循环从250至274 10*gap - 11*gap-1 10*gap+k
# 计算 MLP 的特征重复 循环从275至299 11*gap - 12*gap-1 11*gap+k
# 每一个数据集的第三个项目的 150次实验
# 计算 RF 的特征重复 循环从300至324 12*gap - 13*gap-1  12*gap+k l=2
# 计算 LR 的特征重复 循环从325至349 13*gap - 14*gap-1  13*gap+k
# 计算 NB 的特征重复 循环从350至374 14*gap - 15*gap-1  14*gap+k
# 计算 DT 的特征重复 循环从375至399 15*gap - 16*gap-1  15*gap+k
# 计算 KNN 的特征重复 循环从400至424 16*gap - 17*gap-1  16*gap+k
# 计算 MLP 的特征重复 循环从425至449 17*gap - 18*gap-1  17*gap+k

# 定义间隔 gap = 25 k 从0至24取值 那么 如果一个数据集仅有一个项目 即长度为 len 循环为 len

#简单通过定位测试以上循环是否正确 验证正确


#读取一个得分文件进行测试正确性 而不是排名文件 因为排名文件的分类器编号那列被我移除了 看不出是否正确了

# AEEEM 只有一个数据集 EQ
testdata = pd.DataFrame(pd.read_csv(rootpath + datasets_original + "Promise-permutation-test-auc.csv"))
#print(testdata.loc[0*gap])


"""
print(testdata.loc[0*gap]) #RF
print(testdata.loc[1*gap-1]) #RF
print(testdata.loc[1*gap]) #LR
print(testdata.loc[2*gap-1]) #LR
print(testdata.loc[2*gap]) #NB
print(testdata.loc[3*gap-1]) #NB
print(testdata.loc[3*gap]) #DT
print(testdata.loc[4*gap-1]) #DT
print(testdata.loc[4*gap]) #KNN
print(testdata.loc[5*gap-1]) #KNN
print(testdata.loc[5*gap]) #MLP
print(testdata.loc[6*gap-1]) #MLP
"""
# 第一个项目的150次实验 第二个项目的150次实验 第三个项目的150次实验
# 第一个项目的150次实验 0*gap

"""
for k in range(gap): # 25次
  print(testdata.loc[0*gap+k].values[1])

for k in range(gap):
  print(testdata.loc[1*gap+k].values[1])

for k in range(gap):
  print(testdata.loc[2*gap+k].values[1])

for k in range(gap):
  print(testdata.loc[3*gap+k].values[1])

for k in range(gap):
  print(testdata.loc[4*gap+k].values[1])

for k in range(gap):
  print(testdata.loc[5*gap+k].values[1])
"""

gap = 25
length = len(Promise)
for l in range(length):
  for k in range(gap):
    #print(testdata.loc[l*6*gap+k].values[0]+testdata.loc[l*6*gap+k].values[1])
    print(testdata.loc[(l*6+1)*gap+k].values[0]+testdata.loc[(l*6+1)*gap+k].values[1])
    #print(testdata.loc[(l*6+2)*gap+k].values[0]+testdata.loc[(l*6+2)*gap+k].values[1])
    #print(testdata.loc[(l*6+3)*gap+k].values[0]+testdata.loc[(l*6+3)*gap+k].values[1])
    #print(testdata.loc[(l*6+4)*gap+k].values[0]+testdata.loc[(l*6+4)*gap+k].values[1])
    #print(testdata.loc[(l*6+5)*gap+k].values[0]+testdata.loc[(l*6+5)*gap+k].values[1])

RF_overlap_L_O_1_list = []
RF_overlap_L_O_3_list = []
RF_overlap_L_O_5_list = []

RF_overlap_M_O_1_list = []
RF_overlap_M_O_3_list = []
RF_overlap_M_O_5_list = []

RF_overlap_S_O_1_list = []
RF_overlap_S_O_3_list = []
RF_overlap_S_O_5_list = []

LR_overlap_L_O_1_list = []
LR_overlap_L_O_3_list = []
LR_overlap_L_O_5_list = []

LR_overlap_M_O_1_list = []
LR_overlap_M_O_3_list = []
LR_overlap_M_O_5_list = []

LR_overlap_S_O_1_list = []
LR_overlap_S_O_3_list = []
LR_overlap_S_O_5_list = []

NB_overlap_L_O_1_list = []
NB_overlap_L_O_3_list = []
NB_overlap_L_O_5_list = []

NB_overlap_M_O_1_list = []
NB_overlap_M_O_3_list = []
NB_overlap_M_O_5_list = []

NB_overlap_S_O_1_list = []
NB_overlap_S_O_3_list = []
NB_overlap_S_O_5_list = []

DT_overlap_L_O_1_list = []
DT_overlap_L_O_3_list = []
DT_overlap_L_O_5_list = []

DT_overlap_M_O_1_list = []
DT_overlap_M_O_3_list = []
DT_overlap_M_O_5_list = []

DT_overlap_S_O_1_list = []
DT_overlap_S_O_3_list = []
DT_overlap_S_O_5_list = []

KNN_overlap_L_O_1_list = []
KNN_overlap_L_O_3_list = []
KNN_overlap_L_O_5_list = []

KNN_overlap_M_O_1_list = []
KNN_overlap_M_O_3_list = []
KNN_overlap_M_O_5_list = []

KNN_overlap_S_O_1_list = []
KNN_overlap_S_O_3_list = []
KNN_overlap_S_O_5_list = []

MLP_overlap_L_O_1_list = []
MLP_overlap_L_O_3_list = []
MLP_overlap_L_O_5_list = []

MLP_overlap_M_O_1_list = []
MLP_overlap_M_O_3_list = []
MLP_overlap_M_O_5_list = []

MLP_overlap_S_O_1_list = []
MLP_overlap_S_O_3_list = []
MLP_overlap_S_O_5_list = []

# 按分类器计算 所以一个一个算 先算RF 分类器在所有数据集上的特征重复
# 按数据集项目计算 分开再相加

# 每个分类器依次计算25次实验的重复
# 先算 AEEEM 数据集所有项目 的特征重复

gap = 25
for k in range(gap):

  RF_old_O_1_attrlist = []
  RF_old_O_3_attrlist = []
  RF_old_O_5_attrlist = []

  RF_new_L_1_attrlist = []
  RF_new_L_3_attrlist = []
  RF_new_L_5_attrlist = []

  RF_new_M_1_attrlist = []
  RF_new_M_3_attrlist = []
  RF_new_M_5_attrlist = []

  RF_new_S_1_attrlist = []
  RF_new_S_3_attrlist = []
  RF_new_S_5_attrlist = []


  LR_old_O_1_attrlist = []
  LR_old_O_3_attrlist = []
  LR_old_O_5_attrlist = []

  LR_new_L_1_attrlist = []
  LR_new_L_3_attrlist = []
  LR_new_L_5_attrlist = []

  LR_new_M_1_attrlist = []
  LR_new_M_3_attrlist = []
  LR_new_M_5_attrlist = []

  LR_new_S_1_attrlist = []
  LR_new_S_3_attrlist = []
  LR_new_S_5_attrlist = []

  NB_old_O_1_attrlist = []
  NB_old_O_3_attrlist = []
  NB_old_O_5_attrlist = []

  NB_new_L_1_attrlist = []
  NB_new_L_3_attrlist = []
  NB_new_L_5_attrlist = []

  NB_new_M_1_attrlist = []
  NB_new_M_3_attrlist = []
  NB_new_M_5_attrlist = []

  NB_new_S_1_attrlist = []
  NB_new_S_3_attrlist = []
  NB_new_S_5_attrlist = []

  DT_old_O_1_attrlist = []
  DT_old_O_3_attrlist = []
  DT_old_O_5_attrlist = []

  DT_new_L_1_attrlist = []
  DT_new_L_3_attrlist = []
  DT_new_L_5_attrlist = []

  DT_new_M_1_attrlist = []
  DT_new_M_3_attrlist = []
  DT_new_M_5_attrlist = []

  DT_new_S_1_attrlist = []
  DT_new_S_3_attrlist = []
  DT_new_S_5_attrlist = []

  KNN_old_O_1_attrlist = []
  KNN_old_O_3_attrlist = []
  KNN_old_O_5_attrlist = []

  KNN_new_L_1_attrlist = []
  KNN_new_L_3_attrlist = []
  KNN_new_L_5_attrlist = []

  KNN_new_M_1_attrlist = []
  KNN_new_M_3_attrlist = []
  KNN_new_M_5_attrlist = []

  KNN_new_S_1_attrlist = []
  KNN_new_S_3_attrlist = []
  KNN_new_S_5_attrlist = []

  MLP_old_O_1_attrlist = []
  MLP_old_O_3_attrlist = []
  MLP_old_O_5_attrlist = []

  MLP_new_L_1_attrlist = []
  MLP_new_L_3_attrlist = []
  MLP_new_L_5_attrlist = []

  MLP_new_M_1_attrlist = []
  MLP_new_M_3_attrlist = []
  MLP_new_M_5_attrlist = []

  MLP_new_S_1_attrlist = []
  MLP_new_S_3_attrlist = []
  MLP_new_S_5_attrlist = []

  for j in range(data_o_AEEEM.shape[1]): # 20 26 61

      # 计算 RF top-1 overlap
      if(data_o_AEEEM.loc[(0*gap+k)].values[j] == 1):
        RF_old_O_1_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(0*gap+k)].values[j] == 1):
        RF_new_L_1_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(0*gap+k)].values[j] == 1):
        RF_new_M_1_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(0*gap+k)].values[j] == 1):
        RF_new_S_1_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 LR top-1 overlap
      if(data_o_AEEEM.loc[(1*gap+k)].values[j] == 1):
        LR_old_O_1_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(1*gap+k)].values[j] == 1):
        LR_new_L_1_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(1*gap+k)].values[j] == 1):
        LR_new_M_1_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(1*gap+k)].values[j] == 1):
        LR_new_S_1_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 NB top-1 overlap
      if(data_o_AEEEM.loc[(2*gap+k)].values[j] == 1):
        NB_old_O_1_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(2*gap+k)].values[j] == 1):
        NB_new_L_1_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(2*gap+k)].values[j] == 1):
        NB_new_M_1_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(2*gap+k)].values[j] == 1):
        NB_new_S_1_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 DT top-1 overlap
      if(data_o_AEEEM.loc[(3*gap+k)].values[j] == 1):
        DT_old_O_1_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(3*gap+k)].values[j] == 1):
        DT_new_L_1_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(3*gap+k)].values[j] == 1):
        DT_new_M_1_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(3*gap+k)].values[j] == 1):
        DT_new_S_1_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 KNN top-1 overlap
      if(data_o_AEEEM.loc[(4*gap+k)].values[j] == 1):
        KNN_old_O_1_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(4*gap+k)].values[j] == 1):
        KNN_new_L_1_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(4*gap+k)].values[j] == 1):
        KNN_new_M_1_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(4*gap+k)].values[j] == 1):
        KNN_new_S_1_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 MLP top-1 overlap
      if(data_o_AEEEM.loc[(5*gap+k)].values[j] == 1):
        MLP_old_O_1_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(5*gap+k)].values[j] == 1):
        MLP_new_L_1_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(5*gap+k)].values[j] == 1):
        MLP_new_M_1_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(5*gap+k)].values[j] == 1):
        MLP_new_S_1_attrlist.append(list(data_sta_AEEEM)[j])



      # 计算 RF top-3 overlap
      if(data_o_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(0*gap+k)].values[j] == 3):  # =1 overlap-1 =3 overlap-3
        RF_old_O_3_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(0*gap+k)].values[j] == 3):
        RF_new_L_3_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(0*gap+k)].values[j] == 3):
        RF_new_M_3_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(0*gap+k)].values[j] == 3):
        RF_new_S_3_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 LR top-3 overlap
      if(data_o_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(1*gap+k)].values[j] == 3):  # =1 overlap-1 =3 overlap-3
       LR_old_O_3_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(1*gap+k)].values[j] == 3):
       LR_new_L_3_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(1*gap+k)].values[j] == 3):
       LR_new_M_3_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(1*gap+k)].values[j] == 3):
       LR_new_S_3_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 NB top-3 overlap
      if(data_o_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(2*gap+k)].values[j] == 3):  # =1 overlap-1 =3 overlap-3
        NB_old_O_3_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(2*gap+k)].values[j] == 3):
        NB_new_L_3_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(2*gap+k)].values[j] == 3):
        NB_new_M_3_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(2*gap+k)].values[j] == 3):
        NB_new_S_3_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 DT top-3 overlap
      if(data_o_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(3*gap+k)].values[j] == 3):  # =1 overlap-1 =3 overlap-3
        DT_old_O_3_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(3*gap+k)].values[j] == 3):
        DT_new_L_3_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(3*gap+k)].values[j] == 3):
        DT_new_M_3_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(3*gap+k)].values[j] == 3):
        DT_new_S_3_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 KNN top-3 overlap
      if(data_o_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(4*gap+k)].values[j] == 3):  # =1 overlap-1 =3 overlap-3
        KNN_old_O_3_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(4*gap+k)].values[j] == 3):
        KNN_new_L_3_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(4*gap+k)].values[j] == 3):
        KNN_new_M_3_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(4*gap+k)].values[j] == 3):
        KNN_new_S_3_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 MLP top-3 overlap
      if(data_o_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(5*gap+k)].values[j] == 3):  # =1 overlap-1 =3 overlap-3
        MLP_old_O_3_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(5*gap+k)].values[j] == 3):
        MLP_new_L_3_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(5*gap+k)].values[j] == 3):
        MLP_new_M_3_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(5*gap+k)].values[j] == 3):
        MLP_new_S_3_attrlist.append(list(data_sta_AEEEM)[j])


      # 计算 RF top-5 overlap
      if(data_o_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(0*gap+k)].values[j] == 3 or data_o_AEEEM.loc[(0*gap+k)].values[j] == 4 or data_o_AEEEM.loc[(0*gap+k)].values[j] == 5):
        RF_old_O_5_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(0*gap+k)].values[j] == 3 or data_log_AEEEM.loc[(0*gap+k)].values[j] == 4 or data_log_AEEEM.loc[(0*gap+k)].values[j] == 5):
        RF_new_L_5_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(0*gap+k)].values[j] == 3 or data_min_AEEEM.loc[(0*gap+k)].values[j] == 4 or data_min_AEEEM.loc[(0*gap+k)].values[j] == 5):
        RF_new_M_5_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(0*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(0*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(0*gap+k)].values[j] == 3 or data_sta_AEEEM.loc[(0*gap+k)].values[j] == 4 or data_sta_AEEEM.loc[(0*gap+k)].values[j] == 5):
        RF_new_S_5_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 LR top-5 overlap
      if(data_o_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(1*gap+k)].values[j] == 3 or data_o_AEEEM.loc[(1*gap+k)].values[j] == 4 or data_o_AEEEM.loc[(1*gap+k)].values[j] == 5):
        LR_old_O_5_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(1*gap+k)].values[j] == 3 or data_log_AEEEM.loc[(1*gap+k)].values[j] == 4 or data_log_AEEEM.loc[(1*gap+k)].values[j] == 5):
        LR_new_L_5_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(1*gap+k)].values[j] == 3 or data_min_AEEEM.loc[(1*gap+k)].values[j] == 4 or data_min_AEEEM.loc[(1*gap+k)].values[j] == 5):
        LR_new_M_5_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(1*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(1*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(1*gap+k)].values[j] == 3 or data_sta_AEEEM.loc[(1*gap+k)].values[j] == 4 or data_sta_AEEEM.loc[(1*gap+k)].values[j] == 5):
        LR_new_S_5_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 NB top-5 overlap
      if(data_o_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(2*gap+k)].values[j] == 3 or data_o_AEEEM.loc[(2*gap+k)].values[j] == 4 or data_o_AEEEM.loc[(2*gap+k)].values[j] == 5):
        NB_old_O_5_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(2*gap+k)].values[j] == 3 or data_log_AEEEM.loc[(2*gap+k)].values[j] == 4 or data_log_AEEEM.loc[(2*gap+k)].values[j] == 5):
        NB_new_L_5_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(2*gap+k)].values[j] == 3 or data_min_AEEEM.loc[(2*gap+k)].values[j] == 4 or data_min_AEEEM.loc[(2*gap+k)].values[j] == 5):
        NB_new_M_5_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(2*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(2*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(2*gap+k)].values[j] == 3 or data_sta_AEEEM.loc[(2*gap+k)].values[j] == 4 or data_sta_AEEEM.loc[(2*gap+k)].values[j] == 5):
        NB_new_S_5_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 DT top-5 overlap
      if(data_o_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(3*gap+k)].values[j] == 3 or data_o_AEEEM.loc[(3*gap+k)].values[j] == 4 or data_o_AEEEM.loc[(3*gap+k)].values[j] == 5):
        DT_old_O_5_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(3*gap+k)].values[j] == 3 or data_log_AEEEM.loc[(3*gap+k)].values[j] == 4 or data_log_AEEEM.loc[(3*gap+k)].values[j] == 5):
        DT_new_L_5_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(3*gap+k)].values[j] == 3 or data_min_AEEEM.loc[(3*gap+k)].values[j] == 4 or data_min_AEEEM.loc[(3*gap+k)].values[j] == 5):
        DT_new_M_5_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(3*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(3*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(3*gap+k)].values[j] == 3 or data_sta_AEEEM.loc[(3*gap+k)].values[j] == 4 or data_sta_AEEEM.loc[(3*gap+k)].values[j] == 5):
        DT_new_S_5_attrlist.append(list(data_sta_AEEEM)[j])

       # 计算 KNN top-5 overlap
      if(data_o_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(4*gap+k)].values[j] == 3 or data_o_AEEEM.loc[(4*gap+k)].values[j] == 4 or data_o_AEEEM.loc[(4*gap+k)].values[j] == 5):
        KNN_old_O_5_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(4*gap+k)].values[j] == 3 or data_log_AEEEM.loc[(4*gap+k)].values[j] == 4 or data_log_AEEEM.loc[(4*gap+k)].values[j] == 5):
        KNN_new_L_5_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(4*gap+k)].values[j] == 3 or data_min_AEEEM.loc[(4*gap+k)].values[j] == 4 or data_min_AEEEM.loc[(4*gap+k)].values[j] == 5):
        KNN_new_M_5_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(4*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(4*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(4*gap+k)].values[j] == 3 or data_sta_AEEEM.loc[(4*gap+k)].values[j] == 4 or data_sta_AEEEM.loc[(4*gap+k)].values[j] == 5):
        KNN_new_S_5_attrlist.append(list(data_sta_AEEEM)[j])

      # 计算 MLP top-5 overlap
      if(data_o_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_o_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_o_AEEEM.loc[(5*gap+k)].values[j] == 3 or data_o_AEEEM.loc[(5*gap+k)].values[j] == 4 or data_o_AEEEM.loc[(5*gap+k)].values[j] == 5):
        MLP_old_O_5_attrlist.append(list(data_o_AEEEM)[j])
      if(data_log_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_log_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_log_AEEEM.loc[(5*gap+k)].values[j] == 3 or data_log_AEEEM.loc[(5*gap+k)].values[j] == 4 or data_log_AEEEM.loc[(5*gap+k)].values[j] == 5):
        MLP_new_L_5_attrlist.append(list(data_log_AEEEM)[j])
      if(data_min_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_min_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_min_AEEEM.loc[(5*gap+k)].values[j] == 3 or data_min_AEEEM.loc[(5*gap+k)].values[j] == 4 or data_min_AEEEM.loc[(5*gap+k)].values[j] == 5):
        MLP_new_M_5_attrlist.append(list(data_min_AEEEM)[j])
      if(data_sta_AEEEM.loc[(5*gap+k)].values[j] == 1 or data_sta_AEEEM.loc[(5*gap+k)].values[j] == 2 or data_sta_AEEEM.loc[(5*gap+k)].values[j] == 3 or data_sta_AEEEM.loc[(5*gap+k)].values[j] == 4 or data_sta_AEEEM.loc[(5*gap+k)].values[j] == 5):
        MLP_new_S_5_attrlist.append(list(data_sta_AEEEM)[j])




  # 需要检查交集和并集是否与看到的一致，随机挑选验证 验证无误
  #print("LO 1交集")
  #print(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_L_1_attrlist))))
  #print("LO 1并集")
  #print(list(set(RF_old_O_1_attrlist).union(set(RF_new_L_1_attrlist))))


  # 交集/并集
  RF_overlap_L_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_L_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_L_1_attrlist))))
  RF_overlap_L_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_L_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_L_3_attrlist))))
  RF_overlap_L_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_L_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_L_5_attrlist))))

  RF_overlap_M_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_M_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_M_1_attrlist))))
  RF_overlap_M_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_M_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_M_3_attrlist))))
  RF_overlap_M_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_M_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_M_5_attrlist))))

  RF_overlap_S_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_S_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_S_1_attrlist))))
  RF_overlap_S_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_S_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_S_3_attrlist))))
  RF_overlap_S_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_S_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_S_5_attrlist))))

  LR_overlap_L_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_L_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_L_1_attrlist))))
  LR_overlap_L_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_L_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_L_3_attrlist))))
  LR_overlap_L_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_L_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_L_5_attrlist))))

  LR_overlap_M_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_M_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_M_1_attrlist))))
  LR_overlap_M_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_M_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_M_3_attrlist))))
  LR_overlap_M_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_M_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_M_5_attrlist))))

  LR_overlap_S_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_S_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_S_1_attrlist))))
  LR_overlap_S_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_S_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_S_3_attrlist))))
  LR_overlap_S_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_S_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_S_5_attrlist))))

  NB_overlap_L_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_L_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_L_1_attrlist))))
  NB_overlap_L_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_L_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_L_3_attrlist))))
  NB_overlap_L_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_L_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_L_5_attrlist))))

  NB_overlap_M_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_M_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_M_1_attrlist))))
  NB_overlap_M_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_M_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_M_3_attrlist))))
  NB_overlap_M_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_M_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_M_5_attrlist))))

  NB_overlap_S_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_S_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_S_1_attrlist))))
  NB_overlap_S_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_S_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_S_3_attrlist))))
  NB_overlap_S_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_S_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_S_5_attrlist))))

  DT_overlap_L_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_L_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_L_1_attrlist))))
  DT_overlap_L_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_L_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_L_3_attrlist))))
  DT_overlap_L_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_L_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_L_5_attrlist))))

  DT_overlap_M_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_M_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_M_1_attrlist))))
  DT_overlap_M_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_M_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_M_3_attrlist))))
  DT_overlap_M_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_M_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_M_5_attrlist))))

  DT_overlap_S_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_S_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_S_1_attrlist))))
  DT_overlap_S_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_S_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_S_3_attrlist))))
  DT_overlap_S_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_S_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_S_5_attrlist))))

  KNN_overlap_L_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_L_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_L_1_attrlist))))
  KNN_overlap_L_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_L_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_L_3_attrlist))))
  KNN_overlap_L_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_L_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_L_5_attrlist))))

  KNN_overlap_M_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_M_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_M_1_attrlist))))
  KNN_overlap_M_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_M_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_M_3_attrlist))))
  KNN_overlap_M_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_M_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_M_5_attrlist))))

  KNN_overlap_S_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_S_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_S_1_attrlist))))
  KNN_overlap_S_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_S_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_S_3_attrlist))))
  KNN_overlap_S_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_S_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_S_5_attrlist))))

  MLP_overlap_L_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_L_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_L_1_attrlist))))
  MLP_overlap_L_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_L_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_L_3_attrlist))))
  MLP_overlap_L_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_L_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_L_5_attrlist))))

  MLP_overlap_M_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_M_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_M_1_attrlist))))
  MLP_overlap_M_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_M_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_M_3_attrlist))))
  MLP_overlap_M_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_M_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_M_5_attrlist))))

  MLP_overlap_S_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_S_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_S_1_attrlist))))
  MLP_overlap_S_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_S_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_S_3_attrlist))))
  MLP_overlap_S_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_S_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_S_5_attrlist))))


  # L_O 表示 Log 和 原始 的重叠 重叠是一个百分比值
  RF_overlap_L_O_1_list.append(RF_overlap_L_O_1)
  RF_overlap_L_O_3_list.append(RF_overlap_L_O_3)
  RF_overlap_L_O_5_list.append(RF_overlap_L_O_5)

  RF_overlap_M_O_1_list.append(RF_overlap_M_O_1)
  RF_overlap_M_O_3_list.append(RF_overlap_M_O_3)
  RF_overlap_M_O_5_list.append(RF_overlap_M_O_5)

  RF_overlap_S_O_1_list.append(RF_overlap_S_O_1)
  RF_overlap_S_O_3_list.append(RF_overlap_S_O_3)
  RF_overlap_S_O_5_list.append(RF_overlap_S_O_5)

  LR_overlap_L_O_1_list.append(LR_overlap_L_O_1)
  LR_overlap_L_O_3_list.append(LR_overlap_L_O_3)
  LR_overlap_L_O_5_list.append(LR_overlap_L_O_5)

  LR_overlap_M_O_1_list.append(LR_overlap_M_O_1)
  LR_overlap_M_O_3_list.append(LR_overlap_M_O_3)
  LR_overlap_M_O_5_list.append(LR_overlap_M_O_5)

  LR_overlap_S_O_1_list.append(LR_overlap_S_O_1)
  LR_overlap_S_O_3_list.append(LR_overlap_S_O_3)
  LR_overlap_S_O_5_list.append(LR_overlap_S_O_5)

  NB_overlap_L_O_1_list.append(NB_overlap_L_O_1)
  NB_overlap_L_O_3_list.append(NB_overlap_L_O_3)
  NB_overlap_L_O_5_list.append(NB_overlap_L_O_5)

  NB_overlap_M_O_1_list.append(NB_overlap_M_O_1)
  NB_overlap_M_O_3_list.append(NB_overlap_M_O_3)
  NB_overlap_M_O_5_list.append(NB_overlap_M_O_5)

  NB_overlap_S_O_1_list.append(NB_overlap_S_O_1)
  NB_overlap_S_O_3_list.append(NB_overlap_S_O_3)
  NB_overlap_S_O_5_list.append(NB_overlap_S_O_5)

  DT_overlap_L_O_1_list.append(DT_overlap_L_O_1)
  DT_overlap_L_O_3_list.append(DT_overlap_L_O_3)
  DT_overlap_L_O_5_list.append(DT_overlap_L_O_5)

  DT_overlap_M_O_1_list.append(DT_overlap_M_O_1)
  DT_overlap_M_O_3_list.append(DT_overlap_M_O_3)
  DT_overlap_M_O_5_list.append(DT_overlap_M_O_5)

  DT_overlap_S_O_1_list.append(DT_overlap_S_O_1)
  DT_overlap_S_O_3_list.append(DT_overlap_S_O_3)
  DT_overlap_S_O_5_list.append(DT_overlap_S_O_5)

  KNN_overlap_L_O_1_list.append(KNN_overlap_L_O_1)
  KNN_overlap_L_O_3_list.append(KNN_overlap_L_O_3)
  KNN_overlap_L_O_5_list.append(KNN_overlap_L_O_5)

  KNN_overlap_M_O_1_list.append(KNN_overlap_M_O_1)
  KNN_overlap_M_O_3_list.append(KNN_overlap_M_O_3)
  KNN_overlap_M_O_5_list.append(KNN_overlap_M_O_5)

  KNN_overlap_S_O_1_list.append(KNN_overlap_S_O_1)
  KNN_overlap_S_O_3_list.append(KNN_overlap_S_O_3)
  KNN_overlap_S_O_5_list.append(KNN_overlap_S_O_5)

  MLP_overlap_L_O_1_list.append(MLP_overlap_L_O_1)
  MLP_overlap_L_O_3_list.append(MLP_overlap_L_O_3)
  MLP_overlap_L_O_5_list.append(MLP_overlap_L_O_5)

  MLP_overlap_M_O_1_list.append(MLP_overlap_M_O_1)
  MLP_overlap_M_O_3_list.append(MLP_overlap_M_O_3)
  MLP_overlap_M_O_5_list.append(MLP_overlap_M_O_5)

  MLP_overlap_S_O_1_list.append(MLP_overlap_S_O_1)
  MLP_overlap_S_O_3_list.append(MLP_overlap_S_O_3)
  MLP_overlap_S_O_5_list.append(MLP_overlap_S_O_5)

# 每个分类器依次计算25次实验的重复
# 再算 ReLink 数据集所有项目 的特征重复 ReLink 有三个项目

gap = 25
length = len(ReLink)

for l in range(length):

	for k in range(gap):

		RF_old_O_1_attrlist = []
		RF_old_O_3_attrlist = []
		RF_old_O_5_attrlist = []

		RF_new_L_1_attrlist = []
		RF_new_L_3_attrlist = []
		RF_new_L_5_attrlist = []

		RF_new_M_1_attrlist = []
		RF_new_M_3_attrlist = []
		RF_new_M_5_attrlist = []

		RF_new_S_1_attrlist = []
		RF_new_S_3_attrlist = []
		RF_new_S_5_attrlist = []


		LR_old_O_1_attrlist = []
		LR_old_O_3_attrlist = []
		LR_old_O_5_attrlist = []

		LR_new_L_1_attrlist = []
		LR_new_L_3_attrlist = []
		LR_new_L_5_attrlist = []

		LR_new_M_1_attrlist = []
		LR_new_M_3_attrlist = []
		LR_new_M_5_attrlist = []

		LR_new_S_1_attrlist = []
		LR_new_S_3_attrlist = []
		LR_new_S_5_attrlist = []

		NB_old_O_1_attrlist = []
		NB_old_O_3_attrlist = []
		NB_old_O_5_attrlist = []

		NB_new_L_1_attrlist = []
		NB_new_L_3_attrlist = []
		NB_new_L_5_attrlist = []

		NB_new_M_1_attrlist = []
		NB_new_M_3_attrlist = []
		NB_new_M_5_attrlist = []

		NB_new_S_1_attrlist = []
		NB_new_S_3_attrlist = []
		NB_new_S_5_attrlist = []

		DT_old_O_1_attrlist = []
		DT_old_O_3_attrlist = []
		DT_old_O_5_attrlist = []

		DT_new_L_1_attrlist = []
		DT_new_L_3_attrlist = []
		DT_new_L_5_attrlist = []

		DT_new_M_1_attrlist = []
		DT_new_M_3_attrlist = []
		DT_new_M_5_attrlist = []

		DT_new_S_1_attrlist = []
		DT_new_S_3_attrlist = []
		DT_new_S_5_attrlist = []

		KNN_old_O_1_attrlist = []
		KNN_old_O_3_attrlist = []
		KNN_old_O_5_attrlist = []

		KNN_new_L_1_attrlist = []
		KNN_new_L_3_attrlist = []
		KNN_new_L_5_attrlist = []

		KNN_new_M_1_attrlist = []
		KNN_new_M_3_attrlist = []
		KNN_new_M_5_attrlist = []

		KNN_new_S_1_attrlist = []
		KNN_new_S_3_attrlist = []
		KNN_new_S_5_attrlist = []

		MLP_old_O_1_attrlist = []
		MLP_old_O_3_attrlist = []
		MLP_old_O_5_attrlist = []

		MLP_new_L_1_attrlist = []
		MLP_new_L_3_attrlist = []
		MLP_new_L_5_attrlist = []

		MLP_new_M_1_attrlist = []
		MLP_new_M_3_attrlist = []
		MLP_new_M_5_attrlist = []

		MLP_new_S_1_attrlist = []
		MLP_new_S_3_attrlist = []
		MLP_new_S_5_attrlist = []

		for j in range(data_o_ReLink.shape[1]): # 20 26 61

			# 计算 RF top-1 overlap
			if(data_o_ReLink.loc[l*6*gap+k].values[j] == 1):
				RF_old_O_1_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[l*6*gap+k].values[j] == 1):
				RF_new_L_1_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[l*6*gap+k].values[j] == 1):
				RF_new_M_1_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[l*6*gap+k].values[j] == 1):
				RF_new_S_1_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 LR top-1 overlap
			if(data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_old_O_1_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_new_L_1_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_new_M_1_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_new_S_1_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 NB top-1 overlap
			if(data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_old_O_1_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_new_L_1_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_new_M_1_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_new_S_1_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 DT top-1 overlap
			if(data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_old_O_1_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_new_L_1_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_new_M_1_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_new_S_1_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 KNN top-1 overlap
			if(data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_old_O_1_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_new_L_1_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_new_M_1_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_new_S_1_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 MLP top-1 overlap
			if(data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_old_O_1_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_new_L_1_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_new_M_1_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_new_S_1_attrlist.append(list(data_sta_ReLink)[j])



			# 计算 RF top-3 overlap
			if(data_o_ReLink.loc[l*6*gap+k].values[j] == 1 or data_o_ReLink.loc[l*6*gap+k].values[j] == 2 or data_o_ReLink.loc[l*6*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				RF_old_O_3_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[l*6*gap+k].values[j] == 1 or data_log_ReLink.loc[l*6*gap+k].values[j] == 2 or data_log_ReLink.loc[l*6*gap+k].values[j] == 3):
				RF_new_L_3_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[l*6*gap+k].values[j] == 1 or data_min_ReLink.loc[l*6*gap+k].values[j] == 2 or data_min_ReLink.loc[l*6*gap+k].values[j] == 3):
				RF_new_M_3_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[l*6*gap+k].values[j] == 1 or data_sta_ReLink.loc[l*6*gap+k].values[j] == 2 or data_sta_ReLink.loc[l*6*gap+k].values[j] == 3):
				RF_new_S_3_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 LR top-3 overlap
			if(data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				LR_old_O_3_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 3):
				LR_new_L_3_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 3):
				LR_new_M_3_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 3):
				LR_new_S_3_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 NB top-3 overlap
			if(data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				NB_old_O_3_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 3):
				NB_new_L_3_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 3):
				NB_new_M_3_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 3):
				NB_new_S_3_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 DT top-3 overlap
			if(data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				DT_old_O_3_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 3):
				DT_new_L_3_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 3):
				DT_new_M_3_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 3):
				DT_new_S_3_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 KNN top-3 overlap
			if(data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				KNN_old_O_3_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 3):
				KNN_new_L_3_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 3):
				KNN_new_M_3_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 3):
				KNN_new_S_3_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 MLP top-3 overlap
			if(data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				MLP_old_O_3_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 3):
				MLP_new_L_3_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 3):
				MLP_new_M_3_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 3):
				MLP_new_S_3_attrlist.append(list(data_sta_ReLink)[j])


			# 计算 RF top-5 overlap
			if(data_o_ReLink.loc[l*6*gap+k].values[j] == 1 or data_o_ReLink.loc[l*6*gap+k].values[j] == 2 or data_o_ReLink.loc[l*6*gap+k].values[j] == 3 or data_o_ReLink.loc[l*6*gap+k].values[j] == 4 or data_o_ReLink.loc[l*6*gap+k].values[j] == 5):
				RF_old_O_5_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[l*6*gap+k].values[j] == 1 or data_log_ReLink.loc[l*6*gap+k].values[j] == 2 or data_log_ReLink.loc[l*6*gap+k].values[j] == 3 or data_log_ReLink.loc[l*6*gap+k].values[j] == 4 or data_log_ReLink.loc[l*6*gap+k].values[j] == 5):
				RF_new_L_5_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[l*6*gap+k].values[j] == 1 or data_min_ReLink.loc[l*6*gap+k].values[j] == 2 or data_min_ReLink.loc[l*6*gap+k].values[j] == 3 or data_min_ReLink.loc[l*6*gap+k].values[j] == 4 or data_min_ReLink.loc[l*6*gap+k].values[j] == 5):
				RF_new_M_5_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[l*6*gap+k].values[j] == 1 or data_sta_ReLink.loc[l*6*gap+k].values[j] == 2 or data_sta_ReLink.loc[l*6*gap+k].values[j] == 3 or data_sta_ReLink.loc[l*6*gap+k].values[j] == 4 or data_sta_ReLink.loc[l*6*gap+k].values[j] == 5):
				RF_new_S_5_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 LR top-5 overlap
			if(data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 3 or data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 4 or data_o_ReLink.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_old_O_5_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 3 or data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 4 or data_log_ReLink.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_new_L_5_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 3 or data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 4 or data_min_ReLink.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_new_M_5_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 3 or data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 4 or data_sta_ReLink.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_new_S_5_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 NB top-5 overlap
			if(data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 3 or data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 4 or data_o_ReLink.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_old_O_5_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 3 or data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 4 or data_log_ReLink.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_new_L_5_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 3 or data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 4 or data_min_ReLink.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_new_M_5_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 3 or data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 4 or data_sta_ReLink.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_new_S_5_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 DT top-5 overlap
			if(data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 3 or data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 4 or data_o_ReLink.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_old_O_5_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 3 or data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 4 or data_log_ReLink.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_new_L_5_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 3 or data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 4 or data_min_ReLink.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_new_M_5_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 3 or data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 4 or data_sta_ReLink.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_new_S_5_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 KNN top-5 overlap
			if(data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 3 or data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 4 or data_o_ReLink.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_old_O_5_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 3 or data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 4 or data_log_ReLink.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_new_L_5_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 3 or data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 4 or data_min_ReLink.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_new_M_5_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 3 or data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 4 or data_sta_ReLink.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_new_S_5_attrlist.append(list(data_sta_ReLink)[j])

			# 计算 MLP top-5 overlap
			if(data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 3 or data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 4 or data_o_ReLink.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_old_O_5_attrlist.append(list(data_o_ReLink)[j])
			if(data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 3 or data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 4 or data_log_ReLink.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_new_L_5_attrlist.append(list(data_log_ReLink)[j])
			if(data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 3 or data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 4 or data_min_ReLink.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_new_M_5_attrlist.append(list(data_min_ReLink)[j])
			if(data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 1 or data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 2 or data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 3 or data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 4 or data_sta_ReLink.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_new_S_5_attrlist.append(list(data_sta_ReLink)[j])
		#print("交集")  #验证无误
		#print(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_L_1_attrlist))))
		#print(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_L_1_attrlist))))
    # 交集/并集
		RF_overlap_L_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_L_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_L_1_attrlist))))
		RF_overlap_L_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_L_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_L_3_attrlist))))
		RF_overlap_L_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_L_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_L_5_attrlist))))

		RF_overlap_M_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_M_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_M_1_attrlist))))
		RF_overlap_M_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_M_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_M_3_attrlist))))
		RF_overlap_M_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_M_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_M_5_attrlist))))

		RF_overlap_S_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_S_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_S_1_attrlist))))
		RF_overlap_S_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_S_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_S_3_attrlist))))
		RF_overlap_S_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_S_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_S_5_attrlist))))

		LR_overlap_L_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_L_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_L_1_attrlist))))
		LR_overlap_L_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_L_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_L_3_attrlist))))
		LR_overlap_L_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_L_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_L_5_attrlist))))

		LR_overlap_M_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_M_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_M_1_attrlist))))
		LR_overlap_M_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_M_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_M_3_attrlist))))
		LR_overlap_M_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_M_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_M_5_attrlist))))

		LR_overlap_S_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_S_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_S_1_attrlist))))
		LR_overlap_S_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_S_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_S_3_attrlist))))
		LR_overlap_S_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_S_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_S_5_attrlist))))

		NB_overlap_L_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_L_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_L_1_attrlist))))
		NB_overlap_L_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_L_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_L_3_attrlist))))
		NB_overlap_L_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_L_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_L_5_attrlist))))

		NB_overlap_M_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_M_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_M_1_attrlist))))
		NB_overlap_M_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_M_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_M_3_attrlist))))
		NB_overlap_M_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_M_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_M_5_attrlist))))

		NB_overlap_S_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_S_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_S_1_attrlist))))
		NB_overlap_S_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_S_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_S_3_attrlist))))
		NB_overlap_S_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_S_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_S_5_attrlist))))

		DT_overlap_L_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_L_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_L_1_attrlist))))
		DT_overlap_L_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_L_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_L_3_attrlist))))
		DT_overlap_L_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_L_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_L_5_attrlist))))

		DT_overlap_M_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_M_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_M_1_attrlist))))
		DT_overlap_M_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_M_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_M_3_attrlist))))
		DT_overlap_M_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_M_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_M_5_attrlist))))

		DT_overlap_S_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_S_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_S_1_attrlist))))
		DT_overlap_S_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_S_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_S_3_attrlist))))
		DT_overlap_S_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_S_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_S_5_attrlist))))

		KNN_overlap_L_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_L_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_L_1_attrlist))))
		KNN_overlap_L_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_L_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_L_3_attrlist))))
		KNN_overlap_L_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_L_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_L_5_attrlist))))

		KNN_overlap_M_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_M_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_M_1_attrlist))))
		KNN_overlap_M_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_M_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_M_3_attrlist))))
		KNN_overlap_M_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_M_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_M_5_attrlist))))

		KNN_overlap_S_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_S_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_S_1_attrlist))))
		KNN_overlap_S_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_S_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_S_3_attrlist))))
		KNN_overlap_S_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_S_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_S_5_attrlist))))

		MLP_overlap_L_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_L_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_L_1_attrlist))))
		MLP_overlap_L_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_L_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_L_3_attrlist))))
		MLP_overlap_L_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_L_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_L_5_attrlist))))

		MLP_overlap_M_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_M_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_M_1_attrlist))))
		MLP_overlap_M_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_M_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_M_3_attrlist))))
		MLP_overlap_M_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_M_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_M_5_attrlist))))

		MLP_overlap_S_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_S_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_S_1_attrlist))))
		MLP_overlap_S_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_S_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_S_3_attrlist))))
		MLP_overlap_S_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_S_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_S_5_attrlist))))


		# L_O 表示 Log 和 原始 的重叠 重叠是一个百分比值
		RF_overlap_L_O_1_list.append(RF_overlap_L_O_1)
		RF_overlap_L_O_3_list.append(RF_overlap_L_O_3)
		RF_overlap_L_O_5_list.append(RF_overlap_L_O_5)

		RF_overlap_M_O_1_list.append(RF_overlap_M_O_1)
		RF_overlap_M_O_3_list.append(RF_overlap_M_O_3)
		RF_overlap_M_O_5_list.append(RF_overlap_M_O_5)

		RF_overlap_S_O_1_list.append(RF_overlap_S_O_1)
		RF_overlap_S_O_3_list.append(RF_overlap_S_O_3)
		RF_overlap_S_O_5_list.append(RF_overlap_S_O_5)

		LR_overlap_L_O_1_list.append(LR_overlap_L_O_1)
		LR_overlap_L_O_3_list.append(LR_overlap_L_O_3)
		LR_overlap_L_O_5_list.append(LR_overlap_L_O_5)

		LR_overlap_M_O_1_list.append(LR_overlap_M_O_1)
		LR_overlap_M_O_3_list.append(LR_overlap_M_O_3)
		LR_overlap_M_O_5_list.append(LR_overlap_M_O_5)

		LR_overlap_S_O_1_list.append(LR_overlap_S_O_1)
		LR_overlap_S_O_3_list.append(LR_overlap_S_O_3)
		LR_overlap_S_O_5_list.append(LR_overlap_S_O_5)

		NB_overlap_L_O_1_list.append(NB_overlap_L_O_1)
		NB_overlap_L_O_3_list.append(NB_overlap_L_O_3)
		NB_overlap_L_O_5_list.append(NB_overlap_L_O_5)

		NB_overlap_M_O_1_list.append(NB_overlap_M_O_1)
		NB_overlap_M_O_3_list.append(NB_overlap_M_O_3)
		NB_overlap_M_O_5_list.append(NB_overlap_M_O_5)

		NB_overlap_S_O_1_list.append(NB_overlap_S_O_1)
		NB_overlap_S_O_3_list.append(NB_overlap_S_O_3)
		NB_overlap_S_O_5_list.append(NB_overlap_S_O_5)

		DT_overlap_L_O_1_list.append(DT_overlap_L_O_1)
		DT_overlap_L_O_3_list.append(DT_overlap_L_O_3)
		DT_overlap_L_O_5_list.append(DT_overlap_L_O_5)

		DT_overlap_M_O_1_list.append(DT_overlap_M_O_1)
		DT_overlap_M_O_3_list.append(DT_overlap_M_O_3)
		DT_overlap_M_O_5_list.append(DT_overlap_M_O_5)

		DT_overlap_S_O_1_list.append(DT_overlap_S_O_1)
		DT_overlap_S_O_3_list.append(DT_overlap_S_O_3)
		DT_overlap_S_O_5_list.append(DT_overlap_S_O_5)

		KNN_overlap_L_O_1_list.append(KNN_overlap_L_O_1)
		KNN_overlap_L_O_3_list.append(KNN_overlap_L_O_3)
		KNN_overlap_L_O_5_list.append(KNN_overlap_L_O_5)

		KNN_overlap_M_O_1_list.append(KNN_overlap_M_O_1)
		KNN_overlap_M_O_3_list.append(KNN_overlap_M_O_3)
		KNN_overlap_M_O_5_list.append(KNN_overlap_M_O_5)

		KNN_overlap_S_O_1_list.append(KNN_overlap_S_O_1)
		KNN_overlap_S_O_3_list.append(KNN_overlap_S_O_3)
		KNN_overlap_S_O_5_list.append(KNN_overlap_S_O_5)

		MLP_overlap_L_O_1_list.append(MLP_overlap_L_O_1)
		MLP_overlap_L_O_3_list.append(MLP_overlap_L_O_3)
		MLP_overlap_L_O_5_list.append(MLP_overlap_L_O_5)

		MLP_overlap_M_O_1_list.append(MLP_overlap_M_O_1)
		MLP_overlap_M_O_3_list.append(MLP_overlap_M_O_3)
		MLP_overlap_M_O_5_list.append(MLP_overlap_M_O_5)

		MLP_overlap_S_O_1_list.append(MLP_overlap_S_O_1)
		MLP_overlap_S_O_3_list.append(MLP_overlap_S_O_3)
		MLP_overlap_S_O_5_list.append(MLP_overlap_S_O_5)

# 每个分类器依次计算25次实验的重复
# 最后算 Promise 数据集所有项目 的特征重复

gap = 25
length = len(Promise)

for l in range(length):

	for k in range(gap):

		RF_old_O_1_attrlist = []
		RF_old_O_3_attrlist = []
		RF_old_O_5_attrlist = []

		RF_new_L_1_attrlist = []
		RF_new_L_3_attrlist = []
		RF_new_L_5_attrlist = []

		RF_new_M_1_attrlist = []
		RF_new_M_3_attrlist = []
		RF_new_M_5_attrlist = []

		RF_new_S_1_attrlist = []
		RF_new_S_3_attrlist = []
		RF_new_S_5_attrlist = []


		LR_old_O_1_attrlist = []
		LR_old_O_3_attrlist = []
		LR_old_O_5_attrlist = []

		LR_new_L_1_attrlist = []
		LR_new_L_3_attrlist = []
		LR_new_L_5_attrlist = []

		LR_new_M_1_attrlist = []
		LR_new_M_3_attrlist = []
		LR_new_M_5_attrlist = []

		LR_new_S_1_attrlist = []
		LR_new_S_3_attrlist = []
		LR_new_S_5_attrlist = []

		NB_old_O_1_attrlist = []
		NB_old_O_3_attrlist = []
		NB_old_O_5_attrlist = []

		NB_new_L_1_attrlist = []
		NB_new_L_3_attrlist = []
		NB_new_L_5_attrlist = []

		NB_new_M_1_attrlist = []
		NB_new_M_3_attrlist = []
		NB_new_M_5_attrlist = []

		NB_new_S_1_attrlist = []
		NB_new_S_3_attrlist = []
		NB_new_S_5_attrlist = []

		DT_old_O_1_attrlist = []
		DT_old_O_3_attrlist = []
		DT_old_O_5_attrlist = []

		DT_new_L_1_attrlist = []
		DT_new_L_3_attrlist = []
		DT_new_L_5_attrlist = []

		DT_new_M_1_attrlist = []
		DT_new_M_3_attrlist = []
		DT_new_M_5_attrlist = []

		DT_new_S_1_attrlist = []
		DT_new_S_3_attrlist = []
		DT_new_S_5_attrlist = []

		KNN_old_O_1_attrlist = []
		KNN_old_O_3_attrlist = []
		KNN_old_O_5_attrlist = []

		KNN_new_L_1_attrlist = []
		KNN_new_L_3_attrlist = []
		KNN_new_L_5_attrlist = []

		KNN_new_M_1_attrlist = []
		KNN_new_M_3_attrlist = []
		KNN_new_M_5_attrlist = []

		KNN_new_S_1_attrlist = []
		KNN_new_S_3_attrlist = []
		KNN_new_S_5_attrlist = []

		MLP_old_O_1_attrlist = []
		MLP_old_O_3_attrlist = []
		MLP_old_O_5_attrlist = []

		MLP_new_L_1_attrlist = []
		MLP_new_L_3_attrlist = []
		MLP_new_L_5_attrlist = []

		MLP_new_M_1_attrlist = []
		MLP_new_M_3_attrlist = []
		MLP_new_M_5_attrlist = []

		MLP_new_S_1_attrlist = []
		MLP_new_S_3_attrlist = []
		MLP_new_S_5_attrlist = []

		for j in range(data_o_Promise.shape[1]): # 20 26 61

			# 计算 RF top-1 overlap
			if(data_o_Promise.loc[l*6*gap+k].values[j] == 1):
				RF_old_O_1_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[l*6*gap+k].values[j] == 1):
				RF_new_L_1_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[l*6*gap+k].values[j] == 1):
				RF_new_M_1_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[l*6*gap+k].values[j] == 1):
				RF_new_S_1_attrlist.append(list(data_sta_Promise)[j])

			# 计算 LR top-1 overlap
			if(data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_old_O_1_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_new_L_1_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_new_M_1_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 1):
				LR_new_S_1_attrlist.append(list(data_sta_Promise)[j])

			# 计算 NB top-1 overlap
			if(data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_old_O_1_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_new_L_1_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_new_M_1_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 1):
				NB_new_S_1_attrlist.append(list(data_sta_Promise)[j])

			# 计算 DT top-1 overlap
			if(data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_old_O_1_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_new_L_1_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_new_M_1_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 1):
				DT_new_S_1_attrlist.append(list(data_sta_Promise)[j])

			# 计算 KNN top-1 overlap
			if(data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_old_O_1_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_new_L_1_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_new_M_1_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 1):
				KNN_new_S_1_attrlist.append(list(data_sta_Promise)[j])

			# 计算 MLP top-1 overlap
			if(data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_old_O_1_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_new_L_1_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_new_M_1_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 1):
				MLP_new_S_1_attrlist.append(list(data_sta_Promise)[j])



			# 计算 RF top-3 overlap
			if(data_o_Promise.loc[l*6*gap+k].values[j] == 1 or data_o_Promise.loc[l*6*gap+k].values[j] == 2 or data_o_Promise.loc[l*6*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				RF_old_O_3_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[l*6*gap+k].values[j] == 1 or data_log_Promise.loc[l*6*gap+k].values[j] == 2 or data_log_Promise.loc[l*6*gap+k].values[j] == 3):
				RF_new_L_3_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[l*6*gap+k].values[j] == 1 or data_min_Promise.loc[l*6*gap+k].values[j] == 2 or data_min_Promise.loc[l*6*gap+k].values[j] == 3):
				RF_new_M_3_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[l*6*gap+k].values[j] == 1 or data_sta_Promise.loc[l*6*gap+k].values[j] == 2 or data_sta_Promise.loc[l*6*gap+k].values[j] == 3):
				RF_new_S_3_attrlist.append(list(data_sta_Promise)[j])

			# 计算 LR top-3 overlap
			if(data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				LR_old_O_3_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 3):
				LR_new_L_3_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 3):
				LR_new_M_3_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 3):
				LR_new_S_3_attrlist.append(list(data_sta_Promise)[j])

			# 计算 NB top-3 overlap
			if(data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				NB_old_O_3_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 3):
				NB_new_L_3_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 3):
				NB_new_M_3_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 3):
				NB_new_S_3_attrlist.append(list(data_sta_Promise)[j])

			# 计算 DT top-3 overlap
			if(data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				DT_old_O_3_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 3):
				DT_new_L_3_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 3):
				DT_new_M_3_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 3):
				DT_new_S_3_attrlist.append(list(data_sta_Promise)[j])

			# 计算 KNN top-3 overlap
			if(data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				KNN_old_O_3_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 3):
				KNN_new_L_3_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 3):
				KNN_new_M_3_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 3):
				KNN_new_S_3_attrlist.append(list(data_sta_Promise)[j])

			# 计算 MLP top-3 overlap
			if(data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 3):  # =1 overlap-1 =3 overlap-3
				MLP_old_O_3_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 3):
				MLP_new_L_3_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 3):
				MLP_new_M_3_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 3):
				MLP_new_S_3_attrlist.append(list(data_sta_Promise)[j])


			# 计算 RF top-5 overlap
			if(data_o_Promise.loc[l*6*gap+k].values[j] == 1 or data_o_Promise.loc[l*6*gap+k].values[j] == 2 or data_o_Promise.loc[l*6*gap+k].values[j] == 3 or data_o_Promise.loc[l*6*gap+k].values[j] == 4 or data_o_Promise.loc[l*6*gap+k].values[j] == 5):
				RF_old_O_5_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[l*6*gap+k].values[j] == 1 or data_log_Promise.loc[l*6*gap+k].values[j] == 2 or data_log_Promise.loc[l*6*gap+k].values[j] == 3 or data_log_Promise.loc[l*6*gap+k].values[j] == 4 or data_log_Promise.loc[l*6*gap+k].values[j] == 5):
				RF_new_L_5_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[l*6*gap+k].values[j] == 1 or data_min_Promise.loc[l*6*gap+k].values[j] == 2 or data_min_Promise.loc[l*6*gap+k].values[j] == 3 or data_min_Promise.loc[l*6*gap+k].values[j] == 4 or data_min_Promise.loc[l*6*gap+k].values[j] == 5):
				RF_new_M_5_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[l*6*gap+k].values[j] == 1 or data_sta_Promise.loc[l*6*gap+k].values[j] == 2 or data_sta_Promise.loc[l*6*gap+k].values[j] == 3 or data_sta_Promise.loc[l*6*gap+k].values[j] == 4 or data_sta_Promise.loc[l*6*gap+k].values[j] == 5):
				RF_new_S_5_attrlist.append(list(data_sta_Promise)[j])

			# 计算 LR top-5 overlap
			if(data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 3 or data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 4 or data_o_Promise.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_old_O_5_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 3 or data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 4 or data_log_Promise.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_new_L_5_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 3 or data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 4 or data_min_Promise.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_new_M_5_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 3 or data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 4 or data_sta_Promise.loc[(l*6+1)*gap+k].values[j] == 5):
				LR_new_S_5_attrlist.append(list(data_sta_Promise)[j])

			# 计算 NB top-5 overlap
			if(data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 3 or data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 4 or data_o_Promise.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_old_O_5_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 3 or data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 4 or data_log_Promise.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_new_L_5_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 3 or data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 4 or data_min_Promise.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_new_M_5_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 3 or data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 4 or data_sta_Promise.loc[(l*6+2)*gap+k].values[j] == 5):
				NB_new_S_5_attrlist.append(list(data_sta_Promise)[j])

			# 计算 DT top-5 overlap
			if(data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 3 or data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 4 or data_o_Promise.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_old_O_5_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 3 or data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 4 or data_log_Promise.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_new_L_5_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 3 or data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 4 or data_min_Promise.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_new_M_5_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 3 or data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 4 or data_sta_Promise.loc[(l*6+3)*gap+k].values[j] == 5):
				DT_new_S_5_attrlist.append(list(data_sta_Promise)[j])

			# 计算 KNN top-5 overlap
			if(data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 3 or data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 4 or data_o_Promise.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_old_O_5_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 3 or data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 4 or data_log_Promise.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_new_L_5_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 3 or data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 4 or data_min_Promise.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_new_M_5_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 3 or data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 4 or data_sta_Promise.loc[(l*6+4)*gap+k].values[j] == 5):
				KNN_new_S_5_attrlist.append(list(data_sta_Promise)[j])

			# 计算 MLP top-5 overlap
			if(data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 3 or data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 4 or data_o_Promise.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_old_O_5_attrlist.append(list(data_o_Promise)[j])
			if(data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 3 or data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 4 or data_log_Promise.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_new_L_5_attrlist.append(list(data_log_Promise)[j])
			if(data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 3 or data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 4 or data_min_Promise.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_new_M_5_attrlist.append(list(data_min_Promise)[j])
			if(data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 1 or data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 2 or data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 3 or data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 4 or data_sta_Promise.loc[(l*6+5)*gap+k].values[j] == 5):
				MLP_new_S_5_attrlist.append(list(data_sta_Promise)[j])


		# 交集/并集
		RF_overlap_L_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_L_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_L_1_attrlist))))
		RF_overlap_L_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_L_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_L_3_attrlist))))
		RF_overlap_L_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_L_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_L_5_attrlist))))

		RF_overlap_M_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_M_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_M_1_attrlist))))
		RF_overlap_M_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_M_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_M_3_attrlist))))
		RF_overlap_M_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_M_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_M_5_attrlist))))

		RF_overlap_S_O_1 = len(list(set(RF_old_O_1_attrlist).intersection(set(RF_new_S_1_attrlist)))) / len(list(set(RF_old_O_1_attrlist).union(set(RF_new_S_1_attrlist))))
		RF_overlap_S_O_3 = len(list(set(RF_old_O_3_attrlist).intersection(set(RF_new_S_3_attrlist)))) / len(list(set(RF_old_O_3_attrlist).union(set(RF_new_S_3_attrlist))))
		RF_overlap_S_O_5 = len(list(set(RF_old_O_5_attrlist).intersection(set(RF_new_S_5_attrlist)))) / len(list(set(RF_old_O_5_attrlist).union(set(RF_new_S_5_attrlist))))

		LR_overlap_L_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_L_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_L_1_attrlist))))
		LR_overlap_L_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_L_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_L_3_attrlist))))
		LR_overlap_L_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_L_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_L_5_attrlist))))

		LR_overlap_M_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_M_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_M_1_attrlist))))
		LR_overlap_M_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_M_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_M_3_attrlist))))
		LR_overlap_M_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_M_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_M_5_attrlist))))

		LR_overlap_S_O_1 = len(list(set(LR_old_O_1_attrlist).intersection(set(LR_new_S_1_attrlist)))) / len(list(set(LR_old_O_1_attrlist).union(set(LR_new_S_1_attrlist))))
		LR_overlap_S_O_3 = len(list(set(LR_old_O_3_attrlist).intersection(set(LR_new_S_3_attrlist)))) / len(list(set(LR_old_O_3_attrlist).union(set(LR_new_S_3_attrlist))))
		LR_overlap_S_O_5 = len(list(set(LR_old_O_5_attrlist).intersection(set(LR_new_S_5_attrlist)))) / len(list(set(LR_old_O_5_attrlist).union(set(LR_new_S_5_attrlist))))

		NB_overlap_L_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_L_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_L_1_attrlist))))
		NB_overlap_L_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_L_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_L_3_attrlist))))
		NB_overlap_L_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_L_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_L_5_attrlist))))

		NB_overlap_M_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_M_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_M_1_attrlist))))
		NB_overlap_M_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_M_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_M_3_attrlist))))
		NB_overlap_M_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_M_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_M_5_attrlist))))

		NB_overlap_S_O_1 = len(list(set(NB_old_O_1_attrlist).intersection(set(NB_new_S_1_attrlist)))) / len(list(set(NB_old_O_1_attrlist).union(set(NB_new_S_1_attrlist))))
		NB_overlap_S_O_3 = len(list(set(NB_old_O_3_attrlist).intersection(set(NB_new_S_3_attrlist)))) / len(list(set(NB_old_O_3_attrlist).union(set(NB_new_S_3_attrlist))))
		NB_overlap_S_O_5 = len(list(set(NB_old_O_5_attrlist).intersection(set(NB_new_S_5_attrlist)))) / len(list(set(NB_old_O_5_attrlist).union(set(NB_new_S_5_attrlist))))

		DT_overlap_L_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_L_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_L_1_attrlist))))
		DT_overlap_L_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_L_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_L_3_attrlist))))
		DT_overlap_L_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_L_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_L_5_attrlist))))

		DT_overlap_M_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_M_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_M_1_attrlist))))
		DT_overlap_M_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_M_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_M_3_attrlist))))
		DT_overlap_M_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_M_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_M_5_attrlist))))

		DT_overlap_S_O_1 = len(list(set(DT_old_O_1_attrlist).intersection(set(DT_new_S_1_attrlist)))) / len(list(set(DT_old_O_1_attrlist).union(set(DT_new_S_1_attrlist))))
		DT_overlap_S_O_3 = len(list(set(DT_old_O_3_attrlist).intersection(set(DT_new_S_3_attrlist)))) / len(list(set(DT_old_O_3_attrlist).union(set(DT_new_S_3_attrlist))))
		DT_overlap_S_O_5 = len(list(set(DT_old_O_5_attrlist).intersection(set(DT_new_S_5_attrlist)))) / len(list(set(DT_old_O_5_attrlist).union(set(DT_new_S_5_attrlist))))

		KNN_overlap_L_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_L_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_L_1_attrlist))))
		KNN_overlap_L_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_L_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_L_3_attrlist))))
		KNN_overlap_L_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_L_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_L_5_attrlist))))

		KNN_overlap_M_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_M_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_M_1_attrlist))))
		KNN_overlap_M_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_M_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_M_3_attrlist))))
		KNN_overlap_M_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_M_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_M_5_attrlist))))

		KNN_overlap_S_O_1 = len(list(set(KNN_old_O_1_attrlist).intersection(set(KNN_new_S_1_attrlist)))) / len(list(set(KNN_old_O_1_attrlist).union(set(KNN_new_S_1_attrlist))))
		KNN_overlap_S_O_3 = len(list(set(KNN_old_O_3_attrlist).intersection(set(KNN_new_S_3_attrlist)))) / len(list(set(KNN_old_O_3_attrlist).union(set(KNN_new_S_3_attrlist))))
		KNN_overlap_S_O_5 = len(list(set(KNN_old_O_5_attrlist).intersection(set(KNN_new_S_5_attrlist)))) / len(list(set(KNN_old_O_5_attrlist).union(set(KNN_new_S_5_attrlist))))

		MLP_overlap_L_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_L_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_L_1_attrlist))))
		MLP_overlap_L_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_L_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_L_3_attrlist))))
		MLP_overlap_L_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_L_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_L_5_attrlist))))

		MLP_overlap_M_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_M_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_M_1_attrlist))))
		MLP_overlap_M_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_M_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_M_3_attrlist))))
		MLP_overlap_M_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_M_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_M_5_attrlist))))

		MLP_overlap_S_O_1 = len(list(set(MLP_old_O_1_attrlist).intersection(set(MLP_new_S_1_attrlist)))) / len(list(set(MLP_old_O_1_attrlist).union(set(MLP_new_S_1_attrlist))))
		MLP_overlap_S_O_3 = len(list(set(MLP_old_O_3_attrlist).intersection(set(MLP_new_S_3_attrlist)))) / len(list(set(MLP_old_O_3_attrlist).union(set(MLP_new_S_3_attrlist))))
		MLP_overlap_S_O_5 = len(list(set(MLP_old_O_5_attrlist).intersection(set(MLP_new_S_5_attrlist)))) / len(list(set(MLP_old_O_5_attrlist).union(set(MLP_new_S_5_attrlist))))


		# L_O 表示 Log 和 原始 的重叠 重叠是一个百分比值
		RF_overlap_L_O_1_list.append(RF_overlap_L_O_1)
		RF_overlap_L_O_3_list.append(RF_overlap_L_O_3)
		RF_overlap_L_O_5_list.append(RF_overlap_L_O_5)

		RF_overlap_M_O_1_list.append(RF_overlap_M_O_1)
		RF_overlap_M_O_3_list.append(RF_overlap_M_O_3)
		RF_overlap_M_O_5_list.append(RF_overlap_M_O_5)

		RF_overlap_S_O_1_list.append(RF_overlap_S_O_1)
		RF_overlap_S_O_3_list.append(RF_overlap_S_O_3)
		RF_overlap_S_O_5_list.append(RF_overlap_S_O_5)

		LR_overlap_L_O_1_list.append(LR_overlap_L_O_1)
		LR_overlap_L_O_3_list.append(LR_overlap_L_O_3)
		LR_overlap_L_O_5_list.append(LR_overlap_L_O_5)

		LR_overlap_M_O_1_list.append(LR_overlap_M_O_1)
		LR_overlap_M_O_3_list.append(LR_overlap_M_O_3)
		LR_overlap_M_O_5_list.append(LR_overlap_M_O_5)

		LR_overlap_S_O_1_list.append(LR_overlap_S_O_1)
		LR_overlap_S_O_3_list.append(LR_overlap_S_O_3)
		LR_overlap_S_O_5_list.append(LR_overlap_S_O_5)

		NB_overlap_L_O_1_list.append(NB_overlap_L_O_1)
		NB_overlap_L_O_3_list.append(NB_overlap_L_O_3)
		NB_overlap_L_O_5_list.append(NB_overlap_L_O_5)

		NB_overlap_M_O_1_list.append(NB_overlap_M_O_1)
		NB_overlap_M_O_3_list.append(NB_overlap_M_O_3)
		NB_overlap_M_O_5_list.append(NB_overlap_M_O_5)

		NB_overlap_S_O_1_list.append(NB_overlap_S_O_1)
		NB_overlap_S_O_3_list.append(NB_overlap_S_O_3)
		NB_overlap_S_O_5_list.append(NB_overlap_S_O_5)

		DT_overlap_L_O_1_list.append(DT_overlap_L_O_1)
		DT_overlap_L_O_3_list.append(DT_overlap_L_O_3)
		DT_overlap_L_O_5_list.append(DT_overlap_L_O_5)

		DT_overlap_M_O_1_list.append(DT_overlap_M_O_1)
		DT_overlap_M_O_3_list.append(DT_overlap_M_O_3)
		DT_overlap_M_O_5_list.append(DT_overlap_M_O_5)

		DT_overlap_S_O_1_list.append(DT_overlap_S_O_1)
		DT_overlap_S_O_3_list.append(DT_overlap_S_O_3)
		DT_overlap_S_O_5_list.append(DT_overlap_S_O_5)

		KNN_overlap_L_O_1_list.append(KNN_overlap_L_O_1)
		KNN_overlap_L_O_3_list.append(KNN_overlap_L_O_3)
		KNN_overlap_L_O_5_list.append(KNN_overlap_L_O_5)

		KNN_overlap_M_O_1_list.append(KNN_overlap_M_O_1)
		KNN_overlap_M_O_3_list.append(KNN_overlap_M_O_3)
		KNN_overlap_M_O_5_list.append(KNN_overlap_M_O_5)

		KNN_overlap_S_O_1_list.append(KNN_overlap_S_O_1)
		KNN_overlap_S_O_3_list.append(KNN_overlap_S_O_3)
		KNN_overlap_S_O_5_list.append(KNN_overlap_S_O_5)

		MLP_overlap_L_O_1_list.append(MLP_overlap_L_O_1)
		MLP_overlap_L_O_3_list.append(MLP_overlap_L_O_3)
		MLP_overlap_L_O_5_list.append(MLP_overlap_L_O_5)

		MLP_overlap_M_O_1_list.append(MLP_overlap_M_O_1)
		MLP_overlap_M_O_3_list.append(MLP_overlap_M_O_3)
		MLP_overlap_M_O_5_list.append(MLP_overlap_M_O_5)

		MLP_overlap_S_O_1_list.append(MLP_overlap_S_O_1)
		MLP_overlap_S_O_3_list.append(MLP_overlap_S_O_3)
		MLP_overlap_S_O_5_list.append(MLP_overlap_S_O_5)

# RF 一个项目时25次实验 一共有1+3+12=16个项目 因此一共有400次实验 所以 OVERLAP-1 就有400个值 Overlap-3 也是400个值 Overlap-5 也是400个值

print(RF_overlap_L_O_1_list)
print(len(RF_overlap_L_O_1_list))
print(RF_overlap_L_O_3_list)
print(len(RF_overlap_L_O_3_list))
print(RF_overlap_L_O_5_list)
print(len(RF_overlap_L_O_5_list))

print(RF_overlap_M_O_1_list)
print(len(RF_overlap_M_O_1_list))
print(RF_overlap_M_O_3_list)
print(len(RF_overlap_S_O_3_list))
print(RF_overlap_M_O_5_list)
print(len(RF_overlap_M_O_5_list))

print(RF_overlap_S_O_1_list)
print(len(RF_overlap_S_O_1_list))
print(RF_overlap_S_O_3_list)
print(len(RF_overlap_S_O_3_list))
print(RF_overlap_S_O_5_list)
print(len(RF_overlap_S_O_5_list))

print(LR_overlap_L_O_1_list)
print(len(LR_overlap_L_O_1_list))
print(LR_overlap_L_O_3_list)
print(len(LR_overlap_L_O_3_list))
print(LR_overlap_L_O_5_list)
print(len(LR_overlap_L_O_5_list))

print(LR_overlap_M_O_1_list)
print(len(LR_overlap_M_O_1_list))
print(LR_overlap_M_O_3_list)
print(len(LR_overlap_S_O_3_list))
print(LR_overlap_M_O_5_list)
print(len(LR_overlap_M_O_5_list))

print(LR_overlap_S_O_1_list)
print(len(LR_overlap_S_O_1_list))
print(LR_overlap_S_O_3_list)
print(len(LR_overlap_S_O_3_list))
print(LR_overlap_S_O_5_list)
print(len(LR_overlap_S_O_5_list))


print(NB_overlap_L_O_1_list)
print(len(NB_overlap_L_O_1_list))
print(NB_overlap_L_O_3_list)
print(len(NB_overlap_L_O_3_list))
print(NB_overlap_L_O_5_list)
print(len(NB_overlap_L_O_5_list))

print(NB_overlap_M_O_1_list)
print(len(NB_overlap_M_O_1_list))
print(NB_overlap_M_O_3_list)
print(len(NB_overlap_S_O_3_list))
print(NB_overlap_M_O_5_list)
print(len(NB_overlap_M_O_5_list))

print(NB_overlap_S_O_1_list)
print(len(NB_overlap_S_O_1_list))
print(NB_overlap_S_O_3_list)
print(len(NB_overlap_S_O_3_list))
print(NB_overlap_S_O_5_list)
print(len(NB_overlap_S_O_5_list))

print(DT_overlap_L_O_1_list)
print(len(DT_overlap_L_O_1_list))
print(DT_overlap_L_O_3_list)
print(len(DT_overlap_L_O_3_list))
print(DT_overlap_L_O_5_list)
print(len(DT_overlap_L_O_5_list))

print(DT_overlap_M_O_1_list)
print(len(DT_overlap_M_O_1_list))
print(DT_overlap_M_O_3_list)
print(len(DT_overlap_S_O_3_list))
print(DT_overlap_M_O_5_list)
print(len(DT_overlap_M_O_5_list))

print(DT_overlap_S_O_1_list)
print(len(DT_overlap_S_O_1_list))
print(DT_overlap_S_O_3_list)
print(len(DT_overlap_S_O_3_list))
print(DT_overlap_S_O_5_list)
print(len(DT_overlap_S_O_5_list))


print(KNN_overlap_L_O_1_list)
print(len(KNN_overlap_L_O_1_list))
print(KNN_overlap_L_O_3_list)
print(len(KNN_overlap_L_O_3_list))
print(KNN_overlap_L_O_5_list)
print(len(KNN_overlap_L_O_5_list))

print(KNN_overlap_M_O_1_list)
print(len(KNN_overlap_M_O_1_list))
print(KNN_overlap_M_O_3_list)
print(len(KNN_overlap_S_O_3_list))
print(KNN_overlap_M_O_5_list)
print(len(KNN_overlap_M_O_5_list))

print(KNN_overlap_S_O_1_list)
print(len(KNN_overlap_S_O_1_list))
print(KNN_overlap_S_O_3_list)
print(len(KNN_overlap_S_O_3_list))
print(KNN_overlap_S_O_5_list)
print(len(KNN_overlap_S_O_5_list))

print(MLP_overlap_L_O_1_list)
print(len(MLP_overlap_L_O_1_list))
print(MLP_overlap_L_O_3_list)
print(len(MLP_overlap_L_O_3_list))
print(MLP_overlap_L_O_5_list)
print(len(MLP_overlap_L_O_5_list))

print(MLP_overlap_M_O_1_list)
print(len(MLP_overlap_M_O_1_list))
print(MLP_overlap_M_O_3_list)
print(len(MLP_overlap_S_O_3_list))
print(MLP_overlap_M_O_5_list)
print(len(MLP_overlap_M_O_5_list))

print(MLP_overlap_S_O_1_list)
print(len(MLP_overlap_S_O_1_list))
print(MLP_overlap_S_O_3_list)
print(len(MLP_overlap_S_O_3_list))
print(MLP_overlap_S_O_5_list)
print(len(MLP_overlap_S_O_5_list))

# 验证中间过程是否正确 随机挑几个对比一下 验证没发现错误

# 计算概率分布的数量 简单看一下统计数据

from collections import Counter

print("RF L---------------------")
print(len(RF_overlap_L_O_1_list))
print(len(RF_overlap_L_O_3_list))
print(len(RF_overlap_L_O_5_list))
print("RF M---------------------")
print(len(RF_overlap_M_O_1_list))
print(len(RF_overlap_M_O_3_list))
print(len(RF_overlap_M_O_5_list))
print("RF S---------------------")
print(len(RF_overlap_S_O_1_list))
print(len(RF_overlap_S_O_3_list))
print(len(RF_overlap_S_O_5_list))
print("RF L COUNT---------------------")
RF_count_L_O_1 = Counter(RF_overlap_L_O_1_list)
print(RF_count_L_O_1)
RF_count_L_O_3 = Counter(RF_overlap_L_O_3_list)
print(RF_count_L_O_3)
RF_count_L_O_5 = Counter(RF_overlap_L_O_5_list)
print(RF_count_L_O_5)
print("RF S COUNT---------------------")
RF_count_S_O_1 = Counter(RF_overlap_S_O_1_list)
print(RF_count_S_O_1)
RF_count_S_O_3 = Counter(RF_overlap_S_O_3_list)
print(RF_count_S_O_3)
RF_count_S_O_5 = Counter(RF_overlap_S_O_5_list)
print(RF_count_S_O_5)
print("RF M COUNT---------------------")
RF_count_M_O_1 = Counter(RF_overlap_M_O_1_list)
print(RF_count_M_O_1)
RF_count_M_O_3 = Counter(RF_overlap_M_O_3_list)
print(RF_count_M_O_3)
RF_count_M_O_5 = Counter(RF_overlap_M_O_5_list)
print(RF_count_M_O_5)
print("RF L-O ---------------------")
RF_count_L_O_1_pd = pd.DataFrame(RF_count_L_O_1.items(),columns=['label', 'counts'])
RF_count_L_O_1_pd['probability']=RF_count_L_O_1_pd['counts']/len(RF_overlap_L_O_1_list)

RF_count_L_O_3_pd = pd.DataFrame(RF_count_L_O_3.items(),columns=['label', 'counts'])
RF_count_L_O_3_pd['probability']=RF_count_L_O_3_pd['counts']/len(RF_overlap_L_O_1_list)
RF_count_L_O_5_pd = pd.DataFrame(RF_count_L_O_5.items(),columns=['label', 'counts'])
RF_count_L_O_5_pd['probability']=RF_count_L_O_5_pd['counts']/len(RF_overlap_L_O_1_list)
print(RF_count_L_O_1_pd)
print(RF_count_L_O_3_pd)
print(RF_count_L_O_5_pd)

print("RF M-O ---------------------")
RF_count_M_O_1_pd = pd.DataFrame(RF_count_M_O_1.items(),columns=['label', 'counts'])
RF_count_M_O_1_pd['probability']=RF_count_M_O_1_pd['counts']/len(RF_overlap_L_O_1_list)
RF_count_M_O_3_pd = pd.DataFrame(RF_count_M_O_3.items(),columns=['label', 'counts'])
RF_count_M_O_3_pd['probability']=RF_count_M_O_3_pd['counts']/len(RF_overlap_L_O_1_list)
RF_count_M_O_5_pd = pd.DataFrame(RF_count_M_O_5.items(),columns=['label', 'counts'])
RF_count_M_O_5_pd['probability']=RF_count_M_O_5_pd['counts']/len(RF_overlap_L_O_1_list)
print(RF_count_M_O_1_pd)
print(RF_count_M_O_3_pd)
print(RF_count_M_O_5_pd)

print("RF S-O ---------------------")
RF_count_S_O_1_pd = pd.DataFrame(RF_count_S_O_1.items(),columns=['label', 'counts'])
RF_count_S_O_1_pd['probability']=RF_count_S_O_1_pd['counts']/len(RF_overlap_L_O_1_list)
RF_count_S_O_3_pd = pd.DataFrame(RF_count_S_O_3.items(),columns=['label', 'counts'])
RF_count_S_O_3_pd['probability']=RF_count_S_O_3_pd['counts']/len(RF_overlap_L_O_1_list)
RF_count_S_O_5_pd = pd.DataFrame(RF_count_S_O_5.items(),columns=['label', 'counts'])
RF_count_S_O_5_pd['probability']=RF_count_S_O_5_pd['counts']/len(RF_overlap_L_O_1_list)
print(RF_count_S_O_1_pd)
print(RF_count_S_O_3_pd)
print(RF_count_S_O_5_pd)

# 计算概率分布的数量 简单看一下统计数据

from collections import Counter

print("LR L---------------------")
print(len(LR_overlap_L_O_1_list))
print(len(LR_overlap_L_O_3_list))
print(len(LR_overlap_L_O_5_list))
print("LR M---------------------")
print(len(LR_overlap_M_O_1_list))
print(len(LR_overlap_M_O_3_list))
print(len(LR_overlap_M_O_5_list))
print("LR S---------------------")
print(len(LR_overlap_S_O_1_list))
print(len(LR_overlap_S_O_3_list))
print(len(LR_overlap_S_O_5_list))
print("LR L COUNT---------------------")
LR_count_L_O_1 = Counter(LR_overlap_L_O_1_list)
print(LR_count_L_O_1)
LR_count_L_O_3 = Counter(LR_overlap_L_O_3_list)
print(LR_count_L_O_3)
LR_count_L_O_5 = Counter(LR_overlap_L_O_5_list)
print(LR_count_L_O_5)
print("LR S COUNT---------------------")
LR_count_S_O_1 = Counter(LR_overlap_S_O_1_list)
print(LR_count_S_O_1)
LR_count_S_O_3 = Counter(LR_overlap_S_O_3_list)
print(LR_count_S_O_3)
LR_count_S_O_5 = Counter(LR_overlap_S_O_5_list)
print(LR_count_S_O_5)
print("LR M COUNT---------------------")
LR_count_M_O_1 = Counter(LR_overlap_M_O_1_list)
print(LR_count_M_O_1)
LR_count_M_O_3 = Counter(LR_overlap_M_O_3_list)
print(LR_count_M_O_3)
LR_count_M_O_5 = Counter(LR_overlap_M_O_5_list)
print(LR_count_M_O_5)
print("LR L-O ---------------------")
LR_count_L_O_1_pd = pd.DataFrame(LR_count_L_O_1.items(),columns=['label', 'counts'])
LR_count_L_O_1_pd['probability']=LR_count_L_O_1_pd['counts']/len(LR_overlap_L_O_1_list)

LR_count_L_O_3_pd = pd.DataFrame(LR_count_L_O_3.items(),columns=['label', 'counts'])
LR_count_L_O_3_pd['probability']=LR_count_L_O_3_pd['counts']/len(LR_overlap_L_O_1_list)
LR_count_L_O_5_pd = pd.DataFrame(LR_count_L_O_5.items(),columns=['label', 'counts'])
LR_count_L_O_5_pd['probability']=LR_count_L_O_5_pd['counts']/len(LR_overlap_L_O_1_list)
print(LR_count_L_O_1_pd)
print(LR_count_L_O_3_pd)
print(LR_count_L_O_5_pd)

print("LR M-O ---------------------")
LR_count_M_O_1_pd = pd.DataFrame(LR_count_M_O_1.items(),columns=['label', 'counts'])
LR_count_M_O_1_pd['probability']=LR_count_M_O_1_pd['counts']/len(LR_overlap_L_O_1_list)
LR_count_M_O_3_pd = pd.DataFrame(LR_count_M_O_3.items(),columns=['label', 'counts'])
LR_count_M_O_3_pd['probability']=LR_count_M_O_3_pd['counts']/len(LR_overlap_L_O_1_list)
LR_count_M_O_5_pd = pd.DataFrame(LR_count_M_O_5.items(),columns=['label', 'counts'])
LR_count_M_O_5_pd['probability']=LR_count_M_O_5_pd['counts']/len(LR_overlap_L_O_1_list)
print(LR_count_M_O_1_pd)
print(LR_count_M_O_3_pd)
print(LR_count_M_O_5_pd)

print("LR S-O ---------------------")
LR_count_S_O_1_pd = pd.DataFrame(LR_count_S_O_1.items(),columns=['label', 'counts'])
LR_count_S_O_1_pd['probability']=LR_count_S_O_1_pd['counts']/len(LR_overlap_L_O_1_list)
LR_count_S_O_3_pd = pd.DataFrame(LR_count_S_O_3.items(),columns=['label', 'counts'])
LR_count_S_O_3_pd['probability']=LR_count_S_O_3_pd['counts']/len(LR_overlap_L_O_1_list)
LR_count_S_O_5_pd = pd.DataFrame(LR_count_S_O_5.items(),columns=['label', 'counts'])
LR_count_S_O_5_pd['probability']=LR_count_S_O_5_pd['counts']/len(LR_overlap_L_O_1_list)
print(LR_count_S_O_1_pd)
print(LR_count_S_O_3_pd)
print(LR_count_S_O_5_pd)



# 计算概率分布的数量 简单看一下统计数据

from collections import Counter

print("NB L---------------------")
print(len(NB_overlap_L_O_1_list))
print(len(NB_overlap_L_O_3_list))
print(len(NB_overlap_L_O_5_list))
print("NB M---------------------")
print(len(NB_overlap_M_O_1_list))
print(len(NB_overlap_M_O_3_list))
print(len(NB_overlap_M_O_5_list))
print("NB S---------------------")
print(len(NB_overlap_S_O_1_list))
print(len(NB_overlap_S_O_3_list))
print(len(NB_overlap_S_O_5_list))
print("NB L COUNT---------------------")
NB_count_L_O_1 = Counter(NB_overlap_L_O_1_list)
print(NB_count_L_O_1)
NB_count_L_O_3 = Counter(NB_overlap_L_O_3_list)
print(NB_count_L_O_3)
NB_count_L_O_5 = Counter(NB_overlap_L_O_5_list)
print(NB_count_L_O_5)
print("NB S COUNT---------------------")
NB_count_S_O_1 = Counter(NB_overlap_S_O_1_list)
print(NB_count_S_O_1)
NB_count_S_O_3 = Counter(NB_overlap_S_O_3_list)
print(NB_count_S_O_3)
NB_count_S_O_5 = Counter(NB_overlap_S_O_5_list)
print(NB_count_S_O_5)
print("NB M COUNT---------------------")
NB_count_M_O_1 = Counter(NB_overlap_M_O_1_list)
print(NB_count_M_O_1)
NB_count_M_O_3 = Counter(NB_overlap_M_O_3_list)
print(NB_count_M_O_3)
NB_count_M_O_5 = Counter(NB_overlap_M_O_5_list)
print(NB_count_M_O_5)
print("NB L-O ---------------------")
NB_count_L_O_1_pd = pd.DataFrame(NB_count_L_O_1.items(),columns=['label', 'counts'])
NB_count_L_O_1_pd['probability']=NB_count_L_O_1_pd['counts']/len(NB_overlap_L_O_1_list)

NB_count_L_O_3_pd = pd.DataFrame(NB_count_L_O_3.items(),columns=['label', 'counts'])
NB_count_L_O_3_pd['probability']=NB_count_L_O_3_pd['counts']/len(NB_overlap_L_O_1_list)
NB_count_L_O_5_pd = pd.DataFrame(NB_count_L_O_5.items(),columns=['label', 'counts'])
NB_count_L_O_5_pd['probability']=NB_count_L_O_5_pd['counts']/len(NB_overlap_L_O_1_list)
print(NB_count_L_O_1_pd)
print(NB_count_L_O_3_pd)
print(NB_count_L_O_5_pd)

print("NB M-O ---------------------")
NB_count_M_O_1_pd = pd.DataFrame(NB_count_M_O_1.items(),columns=['label', 'counts'])
NB_count_M_O_1_pd['probability']=NB_count_M_O_1_pd['counts']/len(NB_overlap_L_O_1_list)
NB_count_M_O_3_pd = pd.DataFrame(NB_count_M_O_3.items(),columns=['label', 'counts'])
NB_count_M_O_3_pd['probability']=NB_count_M_O_3_pd['counts']/len(NB_overlap_L_O_1_list)
NB_count_M_O_5_pd = pd.DataFrame(NB_count_M_O_5.items(),columns=['label', 'counts'])
NB_count_M_O_5_pd['probability']=NB_count_M_O_5_pd['counts']/len(NB_overlap_L_O_1_list)
print(NB_count_M_O_1_pd)
print(NB_count_M_O_3_pd)
print(NB_count_M_O_5_pd)

print("NB S-O ---------------------")
NB_count_S_O_1_pd = pd.DataFrame(NB_count_S_O_1.items(),columns=['label', 'counts'])
NB_count_S_O_1_pd['probability']=NB_count_S_O_1_pd['counts']/len(NB_overlap_L_O_1_list)
NB_count_S_O_3_pd = pd.DataFrame(NB_count_S_O_3.items(),columns=['label', 'counts'])
NB_count_S_O_3_pd['probability']=NB_count_S_O_3_pd['counts']/len(NB_overlap_L_O_1_list)
NB_count_S_O_5_pd = pd.DataFrame(NB_count_S_O_5.items(),columns=['label', 'counts'])
NB_count_S_O_5_pd['probability']=NB_count_S_O_5_pd['counts']/len(NB_overlap_L_O_1_list)
print(NB_count_S_O_1_pd)
print(NB_count_S_O_3_pd)
print(NB_count_S_O_5_pd)



# 计算概率分布的数量 简单看一下统计数据

from collections import Counter

print("DT L---------------------")
print(len(DT_overlap_L_O_1_list))
print(len(DT_overlap_L_O_3_list))
print(len(DT_overlap_L_O_5_list))
print("DT M---------------------")
print(len(DT_overlap_M_O_1_list))
print(len(DT_overlap_M_O_3_list))
print(len(DT_overlap_M_O_5_list))
print("DT S---------------------")
print(len(DT_overlap_S_O_1_list))
print(len(DT_overlap_S_O_3_list))
print(len(DT_overlap_S_O_5_list))
print("DT L COUNT---------------------")
DT_count_L_O_1 = Counter(DT_overlap_L_O_1_list)
print(DT_count_L_O_1)
DT_count_L_O_3 = Counter(DT_overlap_L_O_3_list)
print(DT_count_L_O_3)
DT_count_L_O_5 = Counter(DT_overlap_L_O_5_list)
print(DT_count_L_O_5)
print("DT S COUNT---------------------")
DT_count_S_O_1 = Counter(DT_overlap_S_O_1_list)
print(DT_count_S_O_1)
DT_count_S_O_3 = Counter(DT_overlap_S_O_3_list)
print(DT_count_S_O_3)
DT_count_S_O_5 = Counter(DT_overlap_S_O_5_list)
print(DT_count_S_O_5)
print("DT M COUNT---------------------")
DT_count_M_O_1 = Counter(DT_overlap_M_O_1_list)
print(DT_count_M_O_1)
DT_count_M_O_3 = Counter(DT_overlap_M_O_3_list)
print(DT_count_M_O_3)
DT_count_M_O_5 = Counter(DT_overlap_M_O_5_list)
print(DT_count_M_O_5)
print("DT L-O ---------------------")
DT_count_L_O_1_pd = pd.DataFrame(DT_count_L_O_1.items(),columns=['label', 'counts'])
DT_count_L_O_1_pd['probability']=DT_count_L_O_1_pd['counts']/len(DT_overlap_L_O_1_list)

DT_count_L_O_3_pd = pd.DataFrame(DT_count_L_O_3.items(),columns=['label', 'counts'])
DT_count_L_O_3_pd['probability']=DT_count_L_O_3_pd['counts']/len(DT_overlap_L_O_1_list)
DT_count_L_O_5_pd = pd.DataFrame(DT_count_L_O_5.items(),columns=['label', 'counts'])
DT_count_L_O_5_pd['probability']=DT_count_L_O_5_pd['counts']/len(DT_overlap_L_O_1_list)
print(DT_count_L_O_1_pd)
print(DT_count_L_O_3_pd)
print(DT_count_L_O_5_pd)

print("DT M-O ---------------------")
DT_count_M_O_1_pd = pd.DataFrame(DT_count_M_O_1.items(),columns=['label', 'counts'])
DT_count_M_O_1_pd['probability']=DT_count_M_O_1_pd['counts']/len(DT_overlap_L_O_1_list)
DT_count_M_O_3_pd = pd.DataFrame(DT_count_M_O_3.items(),columns=['label', 'counts'])
DT_count_M_O_3_pd['probability']=DT_count_M_O_3_pd['counts']/len(DT_overlap_L_O_1_list)
DT_count_M_O_5_pd = pd.DataFrame(DT_count_M_O_5.items(),columns=['label', 'counts'])
DT_count_M_O_5_pd['probability']=DT_count_M_O_5_pd['counts']/len(DT_overlap_L_O_1_list)
print(DT_count_M_O_1_pd)
print(DT_count_M_O_3_pd)
print(DT_count_M_O_5_pd)

print("DT S-O ---------------------")
DT_count_S_O_1_pd = pd.DataFrame(DT_count_S_O_1.items(),columns=['label', 'counts'])
DT_count_S_O_1_pd['probability']=DT_count_S_O_1_pd['counts']/len(DT_overlap_L_O_1_list)
DT_count_S_O_3_pd = pd.DataFrame(DT_count_S_O_3.items(),columns=['label', 'counts'])
DT_count_S_O_3_pd['probability']=DT_count_S_O_3_pd['counts']/len(DT_overlap_L_O_1_list)
DT_count_S_O_5_pd = pd.DataFrame(DT_count_S_O_5.items(),columns=['label', 'counts'])
DT_count_S_O_5_pd['probability']=DT_count_S_O_5_pd['counts']/len(DT_overlap_L_O_1_list)
print(DT_count_S_O_1_pd)
print(DT_count_S_O_3_pd)
print(DT_count_S_O_5_pd)



# 计算概率分布的数量 简单看一下统计数据

from collections import Counter

print("KNN L---------------------")
print(len(KNN_overlap_L_O_1_list))
print(len(KNN_overlap_L_O_3_list))
print(len(KNN_overlap_L_O_5_list))
print("KNN M---------------------")
print(len(KNN_overlap_M_O_1_list))
print(len(KNN_overlap_M_O_3_list))
print(len(KNN_overlap_M_O_5_list))
print("KNN S---------------------")
print(len(KNN_overlap_S_O_1_list))
print(len(KNN_overlap_S_O_3_list))
print(len(KNN_overlap_S_O_5_list))
print("KNN L COUNT---------------------")
KNN_count_L_O_1 = Counter(KNN_overlap_L_O_1_list)
print(KNN_count_L_O_1)
KNN_count_L_O_3 = Counter(KNN_overlap_L_O_3_list)
print(KNN_count_L_O_3)
KNN_count_L_O_5 = Counter(KNN_overlap_L_O_5_list)
print(KNN_count_L_O_5)
print("KNN S COUNT---------------------")
KNN_count_S_O_1 = Counter(KNN_overlap_S_O_1_list)
print(KNN_count_S_O_1)
KNN_count_S_O_3 = Counter(KNN_overlap_S_O_3_list)
print(KNN_count_S_O_3)
KNN_count_S_O_5 = Counter(KNN_overlap_S_O_5_list)
print(KNN_count_S_O_5)
print("KNN M COUNT---------------------")
KNN_count_M_O_1 = Counter(KNN_overlap_M_O_1_list)
print(KNN_count_M_O_1)
KNN_count_M_O_3 = Counter(KNN_overlap_M_O_3_list)
print(KNN_count_M_O_3)
KNN_count_M_O_5 = Counter(KNN_overlap_M_O_5_list)
print(KNN_count_M_O_5)
print("KNN L-O ---------------------")
KNN_count_L_O_1_pd = pd.DataFrame(KNN_count_L_O_1.items(),columns=['label', 'counts'])
KNN_count_L_O_1_pd['probability']=KNN_count_L_O_1_pd['counts']/len(KNN_overlap_L_O_1_list)

KNN_count_L_O_3_pd = pd.DataFrame(KNN_count_L_O_3.items(),columns=['label', 'counts'])
KNN_count_L_O_3_pd['probability']=KNN_count_L_O_3_pd['counts']/len(KNN_overlap_L_O_1_list)
KNN_count_L_O_5_pd = pd.DataFrame(KNN_count_L_O_5.items(),columns=['label', 'counts'])
KNN_count_L_O_5_pd['probability']=KNN_count_L_O_5_pd['counts']/len(KNN_overlap_L_O_1_list)
print(KNN_count_L_O_1_pd)
print(KNN_count_L_O_3_pd)
print(KNN_count_L_O_5_pd)

print("KNN M-O ---------------------")
KNN_count_M_O_1_pd = pd.DataFrame(KNN_count_M_O_1.items(),columns=['label', 'counts'])
KNN_count_M_O_1_pd['probability']=KNN_count_M_O_1_pd['counts']/len(KNN_overlap_L_O_1_list)
KNN_count_M_O_3_pd = pd.DataFrame(KNN_count_M_O_3.items(),columns=['label', 'counts'])
KNN_count_M_O_3_pd['probability']=KNN_count_M_O_3_pd['counts']/len(KNN_overlap_L_O_1_list)
KNN_count_M_O_5_pd = pd.DataFrame(KNN_count_M_O_5.items(),columns=['label', 'counts'])
KNN_count_M_O_5_pd['probability']=KNN_count_M_O_5_pd['counts']/len(KNN_overlap_L_O_1_list)
print(KNN_count_M_O_1_pd)
print(KNN_count_M_O_3_pd)
print(KNN_count_M_O_5_pd)

print("KNN S-O ---------------------")
KNN_count_S_O_1_pd = pd.DataFrame(KNN_count_S_O_1.items(),columns=['label', 'counts'])
KNN_count_S_O_1_pd['probability']=KNN_count_S_O_1_pd['counts']/len(KNN_overlap_L_O_1_list)
KNN_count_S_O_3_pd = pd.DataFrame(KNN_count_S_O_3.items(),columns=['label', 'counts'])
KNN_count_S_O_3_pd['probability']=KNN_count_S_O_3_pd['counts']/len(KNN_overlap_L_O_1_list)
KNN_count_S_O_5_pd = pd.DataFrame(KNN_count_S_O_5.items(),columns=['label', 'counts'])
KNN_count_S_O_5_pd['probability']=KNN_count_S_O_5_pd['counts']/len(KNN_overlap_L_O_1_list)
print(KNN_count_S_O_1_pd)
print(KNN_count_S_O_3_pd)
print(KNN_count_S_O_5_pd)



# 计算概率分布的数量 简单看一下统计数据

from collections import Counter

print("MLP L---------------------")
print(len(MLP_overlap_L_O_1_list))
print(len(MLP_overlap_L_O_3_list))
print(len(MLP_overlap_L_O_5_list))
print("MLP M---------------------")
print(len(MLP_overlap_M_O_1_list))
print(len(MLP_overlap_M_O_3_list))
print(len(MLP_overlap_M_O_5_list))
print("MLP S---------------------")
print(len(MLP_overlap_S_O_1_list))
print(len(MLP_overlap_S_O_3_list))
print(len(MLP_overlap_S_O_5_list))
print("MLP L COUNT---------------------")
MLP_count_L_O_1 = Counter(MLP_overlap_L_O_1_list)
print(MLP_count_L_O_1)
MLP_count_L_O_3 = Counter(MLP_overlap_L_O_3_list)
print(MLP_count_L_O_3)
MLP_count_L_O_5 = Counter(MLP_overlap_L_O_5_list)
print(MLP_count_L_O_5)
print("MLP S COUNT---------------------")
MLP_count_S_O_1 = Counter(MLP_overlap_S_O_1_list)
print(MLP_count_S_O_1)
MLP_count_S_O_3 = Counter(MLP_overlap_S_O_3_list)
print(MLP_count_S_O_3)
MLP_count_S_O_5 = Counter(MLP_overlap_S_O_5_list)
print(MLP_count_S_O_5)
print("MLP M COUNT---------------------")
MLP_count_M_O_1 = Counter(MLP_overlap_M_O_1_list)
print(MLP_count_M_O_1)
MLP_count_M_O_3 = Counter(MLP_overlap_M_O_3_list)
print(MLP_count_M_O_3)
MLP_count_M_O_5 = Counter(MLP_overlap_M_O_5_list)
print(MLP_count_M_O_5)
print("MLP L-O ---------------------")
MLP_count_L_O_1_pd = pd.DataFrame(MLP_count_L_O_1.items(),columns=['label', 'counts'])
MLP_count_L_O_1_pd['probability']=MLP_count_L_O_1_pd['counts']/len(MLP_overlap_L_O_1_list)

MLP_count_L_O_3_pd = pd.DataFrame(MLP_count_L_O_3.items(),columns=['label', 'counts'])
MLP_count_L_O_3_pd['probability']=MLP_count_L_O_3_pd['counts']/len(MLP_overlap_L_O_1_list)
MLP_count_L_O_5_pd = pd.DataFrame(MLP_count_L_O_5.items(),columns=['label', 'counts'])
MLP_count_L_O_5_pd['probability']=MLP_count_L_O_5_pd['counts']/len(MLP_overlap_L_O_1_list)
print(MLP_count_L_O_1_pd)
print(MLP_count_L_O_3_pd)
print(MLP_count_L_O_5_pd)

print("MLP M-O ---------------------")
MLP_count_M_O_1_pd = pd.DataFrame(MLP_count_M_O_1.items(),columns=['label', 'counts'])
MLP_count_M_O_1_pd['probability']=MLP_count_M_O_1_pd['counts']/len(MLP_overlap_L_O_1_list)
MLP_count_M_O_3_pd = pd.DataFrame(MLP_count_M_O_3.items(),columns=['label', 'counts'])
MLP_count_M_O_3_pd['probability']=MLP_count_M_O_3_pd['counts']/len(MLP_overlap_L_O_1_list)
MLP_count_M_O_5_pd = pd.DataFrame(MLP_count_M_O_5.items(),columns=['label', 'counts'])
MLP_count_M_O_5_pd['probability']=MLP_count_M_O_5_pd['counts']/len(MLP_overlap_L_O_1_list)
print(MLP_count_M_O_1_pd)
print(MLP_count_M_O_3_pd)
print(MLP_count_M_O_5_pd)

print("MLP S-O ---------------------")
MLP_count_S_O_1_pd = pd.DataFrame(MLP_count_S_O_1.items(),columns=['label', 'counts'])
MLP_count_S_O_1_pd['probability']=MLP_count_S_O_1_pd['counts']/len(MLP_overlap_L_O_1_list)
MLP_count_S_O_3_pd = pd.DataFrame(MLP_count_S_O_3.items(),columns=['label', 'counts'])
MLP_count_S_O_3_pd['probability']=MLP_count_S_O_3_pd['counts']/len(MLP_overlap_L_O_1_list)
MLP_count_S_O_5_pd = pd.DataFrame(MLP_count_S_O_5.items(),columns=['label', 'counts'])
MLP_count_S_O_5_pd['probability']=MLP_count_S_O_5_pd['counts']/len(MLP_overlap_L_O_1_list)
print(MLP_count_S_O_1_pd)
print(MLP_count_S_O_3_pd)
print(MLP_count_S_O_5_pd)

"""**RF作图**"""

#作图统计 作图用原始的数据列表  用的是这个！！！ 分类器依次作图 RF作图

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt

with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6), sharex=True,  dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)

  #fig,axes=plt.subplots(1,3, figsize=(15, 4))

  axes[0][0].set_title( "RF Top-1 Overlap",loc='center'  )
  axes[0][0].axvline(0, color='black', linestyle=':')
  axes[0][0].axvline(0.25, color='black', linestyle=':')
  axes[0][0].axvline(0.5, color='black', linestyle=':')
  axes[0][0].axvline(0.75, color='black', linestyle=':')
  axes[0][0].axvline(1, color='black', linestyle=':')

  sns.kdeplot(RF_overlap_L_O_1_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][0])
  axes[0][0].set_xticks([0.0,0.5,1.0])
  #axes[0][0].set_yticks([])
  axes[0][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[0][0].set_ylabel( "L vs O")

  xmedian1 = np.median(RF_overlap_L_O_1_list)
  print(xmedian1)
  axes[0][0].axvline(xmedian1, color='red')





  axes[0][1].set_title( "RF Top-3 Overlap",loc='center'  )

  axes[0][1].axvline(0, color='black', linestyle=':')
  axes[0][1].axvline(0.25, color='black', linestyle=':')
  axes[0][1].axvline(0.5, color='black', linestyle=':')
  axes[0][1].axvline(0.75, color='black', linestyle=':')
  axes[0][1].axvline(1, color='black', linestyle=':')


  sns.kdeplot(RF_overlap_L_O_3_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][1])
  axes[0][1].set_ylabel("")
  axes[0][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][1].set_yticks([])

  xmedian2 = np.median(RF_overlap_L_O_3_list)
  print(xmedian2)
  axes[0][1].axvline(xmedian2, color='red')


  axes[0][2].set_title( "RF Top-5 Overlap",loc='center'  )
  axes[0][2].axvline(0, color='black', linestyle=':')
  axes[0][2].axvline(0.25, color='black', linestyle=':')
  axes[0][2].axvline(0.5, color='black', linestyle=':')
  axes[0][2].axvline(0.75, color='black', linestyle=':')
  axes[0][2].axvline(1, color='black', linestyle=':')
  axes[0][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][2].set_yticks([])
  sns.kdeplot(RF_overlap_L_O_5_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][2])

  xmedian3 = np.median(RF_overlap_L_O_5_list)
  print(xmedian3)
  axes[0][2].axvline(xmedian3, color='red')


  axes[1][0].axvline(0, color='black', linestyle=':')
  axes[1][0].axvline(0.25, color='black', linestyle=':')
  axes[1][0].axvline(0.5, color='black', linestyle=':')
  axes[1][0].axvline(0.75, color='black', linestyle=':')
  axes[1][0].axvline(1, color='black', linestyle=':')
  axes[1][0].set_xticks([0.0,0.5,1.0])
  axes[1][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[1][0].set_ylabel( "M vs O")

  sns.kdeplot(RF_overlap_M_O_1_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][0])

  xmedian4 = np.median(RF_overlap_M_O_1_list)
  print(xmedian4)
  axes[1][0].axvline(xmedian4, color='red')


  axes[1][1].axvline(0, color='black', linestyle=':')
  axes[1][1].axvline(0.25, color='black', linestyle=':')
  axes[1][1].axvline(0.5, color='black', linestyle=':')
  axes[1][1].axvline(0.75, color='black', linestyle=':')
  axes[1][1].axvline(1, color='black', linestyle=':')

  axes[1][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][1].set_yticks([])
  sns.kdeplot(RF_overlap_M_O_3_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][1])

  xmedian5 = np.median(RF_overlap_M_O_3_list)
  print(xmedian5)
  axes[1][1].axvline(xmedian5, color='red')


  axes[1][2].axvline(0, color='black', linestyle=':')
  axes[1][2].axvline(0.25, color='black', linestyle=':')
  axes[1][2].axvline(0.5, color='black', linestyle=':')
  axes[1][2].axvline(0.75, color='black', linestyle=':')
  axes[1][2].axvline(1, color='black', linestyle=':')
  axes[1][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][2].set_yticks([])
  sns.kdeplot(RF_overlap_M_O_5_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][2])

  xmedian6 = np.median(RF_overlap_M_O_5_list)
  print(xmedian6)
  axes[1][2].axvline(xmedian6, color='red')


  axes[2][0].axvline(0, color='black', linestyle=':')
  axes[2][0].axvline(0.25, color='black', linestyle=':')
  axes[2][0].axvline(0.5, color='black', linestyle=':')
  axes[2][0].axvline(0.75, color='black', linestyle=':')
  axes[2][0].axvline(1, color='black', linestyle=':')
  axes[2][0].set_xticks([0.0,0.5,1.0])
  axes[2][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[2][0].set_ylabel( "Z vs O")

  sns.kdeplot(RF_overlap_S_O_1_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][0])

  xmedian7 = np.median(RF_overlap_S_O_1_list)
  print(xmedian7)
  axes[2][0].axvline(xmedian7, color='red')

  axes[2][1].axvline(0, color='black', linestyle=':')
  axes[2][1].axvline(0.25, color='black', linestyle=':')
  axes[2][1].axvline(0.5, color='black', linestyle=':')
  axes[2][1].axvline(0.75, color='black', linestyle=':')
  axes[2][1].axvline(1, color='black', linestyle=':')

  axes[2][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][1].set_yticks([])
  sns.kdeplot(RF_overlap_S_O_3_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][1])

  xmedian8 = np.median(RF_overlap_S_O_3_list)
  print(xmedian8)
  axes[2][1].axvline(xmedian8, color='red')

  axes[2][2].axvline(0, color='black', linestyle=':')
  axes[2][2].axvline(0.25, color='black', linestyle=':')
  axes[2][2].axvline(0.5, color='black', linestyle=':')
  axes[2][2].axvline(0.75, color='black', linestyle=':')
  axes[2][2].axvline(1, color='black', linestyle=':')

  axes[2][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][2].set_yticks([])

  sns.kdeplot(RF_overlap_S_O_5_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][2])
  xmedian9 = np.median(RF_overlap_S_O_5_list)
  print(xmedian9)
  axes[2][2].axvline(xmedian9, color='red')

#作图统计 作图用原始的数据列表 论文里用分布图 数据分析时结合 概率分布图和概率值统计 分析 这个作为参考分析！！！！

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt



with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6),sharey=True,sharex=True, dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)



  axes[0][0].set_title( "Top-1 Overlap",loc='center'  )

  sns.histplot(data=RF_overlap_L_O_1_list, kde=True, stat='probability',ax=axes[0][0])

  axes[0][1].set_title( "Top-3 Overlap",loc='center'  )

  sns.histplot(data=RF_overlap_L_O_3_list, kde=True, stat='probability',ax=axes[0][1])

  axes[0][2].set_title( "Top-5 Overlap",loc='center'  )
  sns.histplot(data=RF_overlap_L_O_5_list, kde=True, stat='probability',ax=axes[0][2])



  sns.histplot(data=RF_overlap_M_O_1_list, kde=True, stat='probability',ax=axes[1][0])

  sns.histplot(data=RF_overlap_M_O_3_list, kde=True, stat='probability',ax=axes[1][1])

  sns.histplot(data=RF_overlap_M_O_5_list, kde=True, stat='probability',ax=axes[1][2])



  sns.histplot(data=RF_overlap_S_O_1_list, kde=True, stat='probability',ax=axes[2][0])

  sns.histplot(data=RF_overlap_S_O_3_list, kde=True, stat='probability',ax=axes[2][1])

  sns.histplot(data=RF_overlap_S_O_5_list, kde=True, stat='probability',ax=axes[2][2])

"""**LR作图**"""

#作图统计 作图用原始的数据列表  用的是这个！！！ 分类器依次作图 LR作图

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt

with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6), sharex=True,  dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)

  #fig,axes=plt.subplots(1,3, figsize=(15, 4))

  axes[0][0].set_title( "LR Top-1 Overlap",loc='center'  )
  axes[0][0].axvline(0, color='black', linestyle=':')
  axes[0][0].axvline(0.25, color='black', linestyle=':')
  axes[0][0].axvline(0.5, color='black', linestyle=':')
  axes[0][0].axvline(0.75, color='black', linestyle=':')
  axes[0][0].axvline(1, color='black', linestyle=':')

  axes[0][0].set_xticks([0.0,0.5,1.0])
  #axes[0][0].set_yticks([])
  axes[0][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[0][0].set_ylabel( "L vs O")

  sns.kdeplot(LR_overlap_L_O_1_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][0])

  xmedian1 = np.median(LR_overlap_L_O_1_list)
  print(xmedian1)
  axes[0][0].axvline(xmedian1, color='red')





  axes[0][1].set_title( "LR Top-3 Overlap",loc='center'  )

  axes[0][1].axvline(0, color='black', linestyle=':')
  axes[0][1].axvline(0.25, color='black', linestyle=':')
  axes[0][1].axvline(0.5, color='black', linestyle=':')
  axes[0][1].axvline(0.75, color='black', linestyle=':')
  axes[0][1].axvline(1, color='black', linestyle=':')

  axes[0][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][1].set_yticks([])

  sns.kdeplot(LR_overlap_L_O_3_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][1])

  xmedian2 = np.median(LR_overlap_L_O_3_list)
  print(xmedian2)
  axes[0][1].axvline(xmedian2, color='red')


  axes[0][2].set_title( "LR Top-5 Overlap",loc='center'  )
  axes[0][2].axvline(0, color='black', linestyle=':')
  axes[0][2].axvline(0.25, color='black', linestyle=':')
  axes[0][2].axvline(0.5, color='black', linestyle=':')
  axes[0][2].axvline(0.75, color='black', linestyle=':')
  axes[0][2].axvline(1, color='black', linestyle=':')
  axes[0][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][2].set_yticks([])
  sns.kdeplot(LR_overlap_L_O_5_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][2])

  xmedian3 = np.median(LR_overlap_L_O_5_list)
  print(xmedian3)
  axes[0][2].axvline(xmedian3, color='red')


  axes[1][0].axvline(0, color='black', linestyle=':')
  axes[1][0].axvline(0.25, color='black', linestyle=':')
  axes[1][0].axvline(0.5, color='black', linestyle=':')
  axes[1][0].axvline(0.75, color='black', linestyle=':')
  axes[1][0].axvline(1, color='black', linestyle=':')
  axes[1][0].set_xticks([0.0,0.5,1.0])
  axes[1][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[1][0].set_ylabel( "M vs O")

  sns.kdeplot(LR_overlap_M_O_1_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][0])

  xmedian4 = np.median(LR_overlap_M_O_1_list)
  print(xmedian4)
  axes[1][0].axvline(xmedian4, color='red')


  axes[1][1].axvline(0, color='black', linestyle=':')
  axes[1][1].axvline(0.25, color='black', linestyle=':')
  axes[1][1].axvline(0.5, color='black', linestyle=':')
  axes[1][1].axvline(0.75, color='black', linestyle=':')
  axes[1][1].axvline(1, color='black', linestyle=':')

  axes[1][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][1].set_yticks([])
  sns.kdeplot(LR_overlap_M_O_3_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][1])

  xmedian5 = np.median(LR_overlap_M_O_3_list)
  print(xmedian5)
  axes[1][1].axvline(xmedian5, color='red')


  axes[1][2].axvline(0, color='black', linestyle=':')
  axes[1][2].axvline(0.25, color='black', linestyle=':')
  axes[1][2].axvline(0.5, color='black', linestyle=':')
  axes[1][2].axvline(0.75, color='black', linestyle=':')
  axes[1][2].axvline(1, color='black', linestyle=':')
  axes[1][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][2].set_yticks([])
  sns.kdeplot(LR_overlap_M_O_5_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][2])

  xmedian6 = np.median(LR_overlap_M_O_5_list)
  print(xmedian6)
  axes[1][2].axvline(xmedian6, color='red')


  axes[2][0].axvline(0, color='black', linestyle=':')
  axes[2][0].axvline(0.25, color='black', linestyle=':')
  axes[2][0].axvline(0.5, color='black', linestyle=':')
  axes[2][0].axvline(0.75, color='black', linestyle=':')
  axes[2][0].axvline(1, color='black', linestyle=':')
  axes[2][0].set_xticks([0.0,0.5,1.0])
  axes[2][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[2][0].set_ylabel( "Z vs O")

  sns.kdeplot(LR_overlap_S_O_1_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][0])

  xmedian7 = np.median(LR_overlap_S_O_1_list)
  print(xmedian7)
  axes[2][0].axvline(xmedian7, color='red')

  axes[2][1].axvline(0, color='black', linestyle=':')
  axes[2][1].axvline(0.25, color='black', linestyle=':')
  axes[2][1].axvline(0.5, color='black', linestyle=':')
  axes[2][1].axvline(0.75, color='black', linestyle=':')
  axes[2][1].axvline(1, color='black', linestyle=':')

  axes[2][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][1].set_yticks([])
  sns.kdeplot(LR_overlap_S_O_3_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][1])

  xmedian8 = np.median(LR_overlap_S_O_3_list)
  print(xmedian8)
  axes[2][1].axvline(xmedian8, color='red')

  axes[2][2].axvline(0, color='black', linestyle=':')
  axes[2][2].axvline(0.25, color='black', linestyle=':')
  axes[2][2].axvline(0.5, color='black', linestyle=':')
  axes[2][2].axvline(0.75, color='black', linestyle=':')
  axes[2][2].axvline(1, color='black', linestyle=':')
  axes[2][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][2].set_yticks([])
  sns.kdeplot(LR_overlap_S_O_5_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][2])
  xmedian9 = np.median(LR_overlap_S_O_5_list)
  print(xmedian9)
  axes[2][2].axvline(xmedian9, color='red')

#作图统计 作图用原始的数据列表 论文里用分布图 数据分析时结合 概率分布图和概率值统计 分析 这个作为参考分析！！！！

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt



with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6),sharey=True,sharex=True, dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)



  axes[0][0].set_title( "Top-1 Overlap",loc='center'  )

  sns.histplot(data=LR_overlap_L_O_1_list, kde=True, stat='probability',ax=axes[0][0])

  axes[0][1].set_title( "Top-3 Overlap",loc='center'  )

  sns.histplot(data=LR_overlap_L_O_3_list, kde=True, stat='probability',ax=axes[0][1])

  axes[0][2].set_title( "Top-5 Overlap",loc='center'  )
  sns.histplot(data=LR_overlap_L_O_5_list, kde=True, stat='probability',ax=axes[0][2])



  sns.histplot(data=LR_overlap_M_O_1_list, kde=True, stat='probability',ax=axes[1][0])

  sns.histplot(data=LR_overlap_M_O_3_list, kde=True, stat='probability',ax=axes[1][1])

  sns.histplot(data=LR_overlap_M_O_5_list, kde=True, stat='probability',ax=axes[1][2])



  sns.histplot(data=LR_overlap_S_O_1_list, kde=True, stat='probability',ax=axes[2][0])

  sns.histplot(data=LR_overlap_S_O_3_list, kde=True, stat='probability',ax=axes[2][1])

  sns.histplot(data=LR_overlap_S_O_5_list, kde=True, stat='probability',ax=axes[2][2])

"""**NB作图**"""

#作图统计 作图用原始的数据列表  用的是这个！！！ 分类器依次作图 NB作图

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt

with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6), sharex=True,  dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)

  #fig,axes=plt.subplots(1,3, figsize=(15, 4))

  axes[0][0].set_title( "NB Top-1 Overlap",loc='center'  )
  axes[0][0].axvline(0, color='black', linestyle=':')
  axes[0][0].axvline(0.25, color='black', linestyle=':')
  axes[0][0].axvline(0.5, color='black', linestyle=':')
  axes[0][0].axvline(0.75, color='black', linestyle=':')
  axes[0][0].axvline(1, color='black', linestyle=':')

  axes[0][0].set_xticks([0.0,0.5,1.0])
  #axes[0][0].set_yticks([])
  axes[0][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[0][0].set_ylabel( "L vs O")

  sns.kdeplot(NB_overlap_L_O_1_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][0])

  xmedian1 = np.median(NB_overlap_L_O_1_list)
  print(xmedian1)
  axes[0][0].axvline(xmedian1, color='red')





  axes[0][1].set_title( "NB Top-3 Overlap",loc='center'  )

  axes[0][1].axvline(0, color='black', linestyle=':')
  axes[0][1].axvline(0.25, color='black', linestyle=':')
  axes[0][1].axvline(0.5, color='black', linestyle=':')
  axes[0][1].axvline(0.75, color='black', linestyle=':')
  axes[0][1].axvline(1, color='black', linestyle=':')

  axes[0][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][1].set_yticks([])

  sns.kdeplot(NB_overlap_L_O_3_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][1])

  xmedian2 = np.median(NB_overlap_L_O_3_list)
  print(xmedian2)
  axes[0][1].axvline(xmedian2, color='red')


  axes[0][2].set_title( "NB Top-5 Overlap",loc='center'  )
  axes[0][2].axvline(0, color='black', linestyle=':')
  axes[0][2].axvline(0.25, color='black', linestyle=':')
  axes[0][2].axvline(0.5, color='black', linestyle=':')
  axes[0][2].axvline(0.75, color='black', linestyle=':')
  axes[0][2].axvline(1, color='black', linestyle=':')
  axes[0][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][2].set_yticks([])
  sns.kdeplot(NB_overlap_L_O_5_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][2])

  xmedian3 = np.median(NB_overlap_L_O_5_list)
  print(xmedian3)
  axes[0][2].axvline(xmedian3, color='red')


  axes[1][0].axvline(0, color='black', linestyle=':')
  axes[1][0].axvline(0.25, color='black', linestyle=':')
  axes[1][0].axvline(0.5, color='black', linestyle=':')
  axes[1][0].axvline(0.75, color='black', linestyle=':')
  axes[1][0].axvline(1, color='black', linestyle=':')
  axes[1][0].set_xticks([0.0,0.5,1.0])
  axes[1][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[1][0].set_ylabel( "M vs O")

  sns.kdeplot(NB_overlap_M_O_1_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][0])

  xmedian4 = np.median(NB_overlap_M_O_1_list)
  print(xmedian4)
  axes[1][0].axvline(xmedian4, color='red')


  axes[1][1].axvline(0, color='black', linestyle=':')
  axes[1][1].axvline(0.25, color='black', linestyle=':')
  axes[1][1].axvline(0.5, color='black', linestyle=':')
  axes[1][1].axvline(0.75, color='black', linestyle=':')
  axes[1][1].axvline(1, color='black', linestyle=':')

  axes[1][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][1].set_yticks([])
  sns.kdeplot(NB_overlap_M_O_3_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][1])

  xmedian5 = np.median(NB_overlap_M_O_3_list)
  print(xmedian5)
  axes[1][1].axvline(xmedian5, color='red')


  axes[1][2].axvline(0, color='black', linestyle=':')
  axes[1][2].axvline(0.25, color='black', linestyle=':')
  axes[1][2].axvline(0.5, color='black', linestyle=':')
  axes[1][2].axvline(0.75, color='black', linestyle=':')
  axes[1][2].axvline(1, color='black', linestyle=':')
  axes[1][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][2].set_yticks([])
  sns.kdeplot(NB_overlap_M_O_5_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][2])

  xmedian6 = np.median(NB_overlap_M_O_5_list)
  print(xmedian6)
  axes[1][2].axvline(xmedian6, color='red')


  axes[2][0].axvline(0, color='black', linestyle=':')
  axes[2][0].axvline(0.25, color='black', linestyle=':')
  axes[2][0].axvline(0.5, color='black', linestyle=':')
  axes[2][0].axvline(0.75, color='black', linestyle=':')
  axes[2][0].axvline(1, color='black', linestyle=':')
  axes[2][0].set_xticks([0.0,0.5,1.0])
  axes[2][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[2][0].set_ylabel( "Z vs O")

  sns.kdeplot(NB_overlap_S_O_1_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][0])

  xmedian7 = np.median(NB_overlap_S_O_1_list)
  print(xmedian7)
  axes[2][0].axvline(xmedian7, color='red')

  axes[2][1].axvline(0, color='black', linestyle=':')
  axes[2][1].axvline(0.25, color='black', linestyle=':')
  axes[2][1].axvline(0.5, color='black', linestyle=':')
  axes[2][1].axvline(0.75, color='black', linestyle=':')
  axes[2][1].axvline(1, color='black', linestyle=':')

  axes[2][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][1].set_yticks([])
  sns.kdeplot(NB_overlap_S_O_3_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][1])

  xmedian8 = np.median(NB_overlap_S_O_3_list)
  print(xmedian8)
  axes[2][1].axvline(xmedian8, color='red')

  axes[2][2].axvline(0, color='black', linestyle=':')
  axes[2][2].axvline(0.25, color='black', linestyle=':')
  axes[2][2].axvline(0.5, color='black', linestyle=':')
  axes[2][2].axvline(0.75, color='black', linestyle=':')
  axes[2][2].axvline(1, color='black', linestyle=':')
  axes[2][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][2].set_yticks([])
  sns.kdeplot(NB_overlap_S_O_5_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][2])
  xmedian9 = np.median(NB_overlap_S_O_5_list)
  print(xmedian9)
  axes[2][2].axvline(xmedian9, color='red')

#作图统计 作图用原始的数据列表 论文里用分布图 数据分析时结合 概率分布图和概率值统计 分析 这个作为参考分析！！！！

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt



with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6),sharey=True,sharex=True, dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)



  axes[0][0].set_title( "Top-1 Overlap",loc='center'  )

  sns.histplot(data=NB_overlap_L_O_1_list, kde=True, stat='probability',ax=axes[0][0])

  axes[0][1].set_title( "Top-3 Overlap",loc='center'  )

  sns.histplot(data=NB_overlap_L_O_3_list, kde=True, stat='probability',ax=axes[0][1])

  axes[0][2].set_title( "Top-5 Overlap",loc='center'  )
  sns.histplot(data=NB_overlap_L_O_5_list, kde=True, stat='probability',ax=axes[0][2])



  sns.histplot(data=NB_overlap_M_O_1_list, kde=True, stat='probability',ax=axes[1][0])

  sns.histplot(data=NB_overlap_M_O_3_list, kde=True, stat='probability',ax=axes[1][1])

  sns.histplot(data=NB_overlap_M_O_5_list, kde=True, stat='probability',ax=axes[1][2])



  sns.histplot(data=NB_overlap_S_O_1_list, kde=True, stat='probability',ax=axes[2][0])

  sns.histplot(data=NB_overlap_S_O_3_list, kde=True, stat='probability',ax=axes[2][1])

  sns.histplot(data=NB_overlap_S_O_5_list, kde=True, stat='probability',ax=axes[2][2])

"""**DT作图**"""

#作图统计 作图用原始的数据列表  用的是这个！！！ 分类器依次作图 DT作图

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt

with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6), sharex=True,  dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)

  #fig,axes=plt.subplots(1,3, figsize=(15, 4))

  axes[0][0].set_title( "DT Top-1 Overlap",loc='center'  )
  axes[0][0].axvline(0, color='black', linestyle=':')
  axes[0][0].axvline(0.25, color='black', linestyle=':')
  axes[0][0].axvline(0.5, color='black', linestyle=':')
  axes[0][0].axvline(0.75, color='black', linestyle=':')
  axes[0][0].axvline(1, color='black', linestyle=':')

  axes[0][0].set_xticks([0.0,0.5,1.0])
  #axes[0][0].set_yticks([])
  axes[0][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[0][0].set_ylabel( "L vs O")

  sns.kdeplot(DT_overlap_L_O_1_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][0])

  xmedian1 = np.median(DT_overlap_L_O_1_list)
  print(xmedian1)
  axes[0][0].axvline(xmedian1, color='red')





  axes[0][1].set_title( "DT Top-3 Overlap",loc='center'  )

  axes[0][1].axvline(0, color='black', linestyle=':')
  axes[0][1].axvline(0.25, color='black', linestyle=':')
  axes[0][1].axvline(0.5, color='black', linestyle=':')
  axes[0][1].axvline(0.75, color='black', linestyle=':')
  axes[0][1].axvline(1, color='black', linestyle=':')

  axes[0][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][1].set_yticks([])

  sns.kdeplot(DT_overlap_L_O_3_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][1])

  xmedian2 = np.median(DT_overlap_L_O_3_list)
  print(xmedian2)
  axes[0][1].axvline(xmedian2, color='red')


  axes[0][2].set_title( "DT Top-5 Overlap",loc='center'  )
  axes[0][2].axvline(0, color='black', linestyle=':')
  axes[0][2].axvline(0.25, color='black', linestyle=':')
  axes[0][2].axvline(0.5, color='black', linestyle=':')
  axes[0][2].axvline(0.75, color='black', linestyle=':')
  axes[0][2].axvline(1, color='black', linestyle=':')
  axes[0][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][2].set_yticks([])
  sns.kdeplot(DT_overlap_L_O_5_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][2])

  xmedian3 = np.median(DT_overlap_L_O_5_list)
  print(xmedian3)
  axes[0][2].axvline(xmedian3, color='red')


  axes[1][0].axvline(0, color='black', linestyle=':')
  axes[1][0].axvline(0.25, color='black', linestyle=':')
  axes[1][0].axvline(0.5, color='black', linestyle=':')
  axes[1][0].axvline(0.75, color='black', linestyle=':')
  axes[1][0].axvline(1, color='black', linestyle=':')
  axes[1][0].set_xticks([0.0,0.5,1.0])
  axes[1][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[1][0].set_ylabel( "M vs O")

  sns.kdeplot(DT_overlap_M_O_1_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][0])

  xmedian4 = np.median(DT_overlap_M_O_1_list)
  print(xmedian4)
  axes[1][0].axvline(xmedian4, color='red')


  axes[1][1].axvline(0, color='black', linestyle=':')
  axes[1][1].axvline(0.25, color='black', linestyle=':')
  axes[1][1].axvline(0.5, color='black', linestyle=':')
  axes[1][1].axvline(0.75, color='black', linestyle=':')
  axes[1][1].axvline(1, color='black', linestyle=':')

  axes[1][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][1].set_yticks([])
  sns.kdeplot(DT_overlap_M_O_3_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][1])

  xmedian5 = np.median(DT_overlap_M_O_3_list)
  print(xmedian5)
  axes[1][1].axvline(xmedian5, color='red')


  axes[1][2].axvline(0, color='black', linestyle=':')
  axes[1][2].axvline(0.25, color='black', linestyle=':')
  axes[1][2].axvline(0.5, color='black', linestyle=':')
  axes[1][2].axvline(0.75, color='black', linestyle=':')
  axes[1][2].axvline(1, color='black', linestyle=':')
  axes[1][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][2].set_yticks([])
  sns.kdeplot(DT_overlap_M_O_5_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][2])

  xmedian6 = np.median(DT_overlap_M_O_5_list)
  print(xmedian6)
  axes[1][2].axvline(xmedian6, color='red')


  axes[2][0].axvline(0, color='black', linestyle=':')
  axes[2][0].axvline(0.25, color='black', linestyle=':')
  axes[2][0].axvline(0.5, color='black', linestyle=':')
  axes[2][0].axvline(0.75, color='black', linestyle=':')
  axes[2][0].axvline(1, color='black', linestyle=':')
  axes[2][0].set_xticks([0.0,0.5,1.0])
  axes[2][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[2][0].set_ylabel( "Z vs O")

  sns.kdeplot(DT_overlap_S_O_1_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][0])

  xmedian7 = np.median(DT_overlap_S_O_1_list)
  print(xmedian7)
  axes[2][0].axvline(xmedian7, color='red')

  axes[2][1].axvline(0, color='black', linestyle=':')
  axes[2][1].axvline(0.25, color='black', linestyle=':')
  axes[2][1].axvline(0.5, color='black', linestyle=':')
  axes[2][1].axvline(0.75, color='black', linestyle=':')
  axes[2][1].axvline(1, color='black', linestyle=':')

  axes[2][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][1].set_yticks([])
  sns.kdeplot(DT_overlap_S_O_3_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][1])

  xmedian8 = np.median(DT_overlap_S_O_3_list)
  print(xmedian8)
  axes[2][1].axvline(xmedian8, color='red')

  axes[2][2].axvline(0, color='black', linestyle=':')
  axes[2][2].axvline(0.25, color='black', linestyle=':')
  axes[2][2].axvline(0.5, color='black', linestyle=':')
  axes[2][2].axvline(0.75, color='black', linestyle=':')
  axes[2][2].axvline(1, color='black', linestyle=':')
  axes[2][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][2].set_yticks([])
  sns.kdeplot(DT_overlap_S_O_5_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][2])
  xmedian9 = np.median(DT_overlap_S_O_5_list)
  print(xmedian9)
  axes[2][2].axvline(xmedian9, color='red')

#作图统计 作图用原始的数据列表 论文里用分布图 数据分析时结合 概率分布图和概率值统计 分析 这个作为参考分析！！！！

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt



with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6),sharey=True,sharex=True, dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)



  axes[0][0].set_title( "Top-1 Overlap",loc='center'  )

  sns.histplot(data=DT_overlap_L_O_1_list, kde=True, stat='probability',ax=axes[0][0])

  axes[0][1].set_title( "Top-3 Overlap",loc='center'  )

  sns.histplot(data=DT_overlap_L_O_3_list, kde=True, stat='probability',ax=axes[0][1])

  axes[0][2].set_title( "Top-5 Overlap",loc='center'  )
  sns.histplot(data=DT_overlap_L_O_5_list, kde=True, stat='probability',ax=axes[0][2])



  sns.histplot(data=DT_overlap_M_O_1_list, kde=True, stat='probability',ax=axes[1][0])

  sns.histplot(data=DT_overlap_M_O_3_list, kde=True, stat='probability',ax=axes[1][1])

  sns.histplot(data=DT_overlap_M_O_5_list, kde=True, stat='probability',ax=axes[1][2])



  sns.histplot(data=DT_overlap_S_O_1_list, kde=True, stat='probability',ax=axes[2][0])

  sns.histplot(data=DT_overlap_S_O_3_list, kde=True, stat='probability',ax=axes[2][1])

  sns.histplot(data=DT_overlap_S_O_5_list, kde=True, stat='probability',ax=axes[2][2])

"""**KNN作图**"""

#作图统计 作图用原始的数据列表  用的是这个！！！ 分类器依次作图 KNN作图

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt

with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6), sharex=True,  dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)

  #fig,axes=plt.subplots(1,3, figsize=(15, 4))

  axes[0][0].set_title( "KNN Top-1 Overlap",loc='center'  )
  axes[0][0].axvline(0, color='black', linestyle=':')
  axes[0][0].axvline(0.25, color='black', linestyle=':')
  axes[0][0].axvline(0.5, color='black', linestyle=':')
  axes[0][0].axvline(0.75, color='black', linestyle=':')
  axes[0][0].axvline(1, color='black', linestyle=':')

  axes[0][0].set_xticks([0.0,0.5,1.0])
  #axes[0][0].set_yticks([])
  axes[0][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[0][0].set_ylabel( "L vs O")

  sns.kdeplot(KNN_overlap_L_O_1_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][0])

  xmedian1 = np.median(KNN_overlap_L_O_1_list)
  print(xmedian1)
  axes[0][0].axvline(xmedian1, color='red')





  axes[0][1].set_title( "KNN Top-3 Overlap",loc='center'  )

  axes[0][1].axvline(0, color='black', linestyle=':')
  axes[0][1].axvline(0.25, color='black', linestyle=':')
  axes[0][1].axvline(0.5, color='black', linestyle=':')
  axes[0][1].axvline(0.75, color='black', linestyle=':')
  axes[0][1].axvline(1, color='black', linestyle=':')

  axes[0][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][1].set_yticks([])

  sns.kdeplot(KNN_overlap_L_O_3_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][1])

  xmedian2 = np.median(KNN_overlap_L_O_3_list)
  print(xmedian2)
  axes[0][1].axvline(xmedian2, color='red')


  axes[0][2].set_title( "KNN Top-5 Overlap",loc='center'  )
  axes[0][2].axvline(0, color='black', linestyle=':')
  axes[0][2].axvline(0.25, color='black', linestyle=':')
  axes[0][2].axvline(0.5, color='black', linestyle=':')
  axes[0][2].axvline(0.75, color='black', linestyle=':')
  axes[0][2].axvline(1, color='black', linestyle=':')
  axes[0][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][2].set_yticks([])
  sns.kdeplot(KNN_overlap_L_O_5_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][2])

  xmedian3 = np.median(KNN_overlap_L_O_5_list)
  print(xmedian3)
  axes[0][2].axvline(xmedian3, color='red')


  axes[1][0].axvline(0, color='black', linestyle=':')
  axes[1][0].axvline(0.25, color='black', linestyle=':')
  axes[1][0].axvline(0.5, color='black', linestyle=':')
  axes[1][0].axvline(0.75, color='black', linestyle=':')
  axes[1][0].axvline(1, color='black', linestyle=':')
  axes[1][0].set_xticks([0.0,0.5,1.0])
  axes[1][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[1][0].set_ylabel( "M vs O")

  sns.kdeplot(KNN_overlap_M_O_1_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][0])

  xmedian4 = np.median(KNN_overlap_M_O_1_list)
  print(xmedian4)
  axes[1][0].axvline(xmedian4, color='red')


  axes[1][1].axvline(0, color='black', linestyle=':')
  axes[1][1].axvline(0.25, color='black', linestyle=':')
  axes[1][1].axvline(0.5, color='black', linestyle=':')
  axes[1][1].axvline(0.75, color='black', linestyle=':')
  axes[1][1].axvline(1, color='black', linestyle=':')

  axes[1][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][1].set_yticks([])
  sns.kdeplot(KNN_overlap_M_O_3_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][1])

  xmedian5 = np.median(KNN_overlap_M_O_3_list)
  print(xmedian5)
  axes[1][1].axvline(xmedian5, color='red')


  axes[1][2].axvline(0, color='black', linestyle=':')
  axes[1][2].axvline(0.25, color='black', linestyle=':')
  axes[1][2].axvline(0.5, color='black', linestyle=':')
  axes[1][2].axvline(0.75, color='black', linestyle=':')
  axes[1][2].axvline(1, color='black', linestyle=':')
  axes[1][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][2].set_yticks([])
  sns.kdeplot(KNN_overlap_M_O_5_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][2])

  xmedian6 = np.median(KNN_overlap_M_O_5_list)
  print(xmedian6)
  axes[1][2].axvline(xmedian6, color='red')


  axes[2][0].axvline(0, color='black', linestyle=':')
  axes[2][0].axvline(0.25, color='black', linestyle=':')
  axes[2][0].axvline(0.5, color='black', linestyle=':')
  axes[2][0].axvline(0.75, color='black', linestyle=':')
  axes[2][0].axvline(1, color='black', linestyle=':')
  axes[2][0].set_xticks([0.0,0.5,1.0])
  axes[2][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[2][0].set_ylabel( "Z vs O")

  sns.kdeplot(KNN_overlap_S_O_1_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][0])

  xmedian7 = np.median(KNN_overlap_S_O_1_list)
  print(xmedian7)
  axes[2][0].axvline(xmedian7, color='red')

  axes[2][1].axvline(0, color='black', linestyle=':')
  axes[2][1].axvline(0.25, color='black', linestyle=':')
  axes[2][1].axvline(0.5, color='black', linestyle=':')
  axes[2][1].axvline(0.75, color='black', linestyle=':')
  axes[2][1].axvline(1, color='black', linestyle=':')

  axes[2][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][1].set_yticks([])
  sns.kdeplot(KNN_overlap_S_O_3_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][1])

  xmedian8 = np.median(KNN_overlap_S_O_3_list)
  print(xmedian8)
  axes[2][1].axvline(xmedian8, color='red')

  axes[2][2].axvline(0, color='black', linestyle=':')
  axes[2][2].axvline(0.25, color='black', linestyle=':')
  axes[2][2].axvline(0.5, color='black', linestyle=':')
  axes[2][2].axvline(0.75, color='black', linestyle=':')
  axes[2][2].axvline(1, color='black', linestyle=':')
  axes[2][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][2].set_yticks([])
  sns.kdeplot(KNN_overlap_S_O_5_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][2])
  xmedian9 = np.median(KNN_overlap_S_O_5_list)
  print(xmedian9)
  axes[2][2].axvline(xmedian9, color='red')

#作图统计 作图用原始的数据列表 论文里用分布图 数据分析时结合 概率分布图和概率值统计 分析 这个作为参考分析！！！！

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt



with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6),sharey=True,sharex=True, dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)



  axes[0][0].set_title( "Top-1 Overlap",loc='center'  )

  sns.histplot(data=KNN_overlap_L_O_1_list, kde=True, stat='probability',ax=axes[0][0])

  axes[0][1].set_title( "Top-3 Overlap",loc='center'  )

  sns.histplot(data=KNN_overlap_L_O_3_list, kde=True, stat='probability',ax=axes[0][1])

  axes[0][2].set_title( "Top-5 Overlap",loc='center'  )
  sns.histplot(data=KNN_overlap_L_O_5_list, kde=True, stat='probability',ax=axes[0][2])



  sns.histplot(data=KNN_overlap_M_O_1_list, kde=True, stat='probability',ax=axes[1][0])

  sns.histplot(data=KNN_overlap_M_O_3_list, kde=True, stat='probability',ax=axes[1][1])

  sns.histplot(data=KNN_overlap_M_O_5_list, kde=True, stat='probability',ax=axes[1][2])



  sns.histplot(data=KNN_overlap_S_O_1_list, kde=True, stat='probability',ax=axes[2][0])

  sns.histplot(data=KNN_overlap_S_O_3_list, kde=True, stat='probability',ax=axes[2][1])

  sns.histplot(data=KNN_overlap_S_O_5_list, kde=True, stat='probability',ax=axes[2][2])

"""**MLP作图**"""

#作图统计 作图用原始的数据列表  用的是这个！！！ 分类器依次作图 MLP作图

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt

with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6), sharex=True,  dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)

  #fig,axes=plt.subplots(1,3, figsize=(15, 4))

  axes[0][0].set_title( "MLP Top-1 Overlap",loc='center'  )
  axes[0][0].axvline(0, color='black', linestyle=':')
  axes[0][0].axvline(0.25, color='black', linestyle=':')
  axes[0][0].axvline(0.5, color='black', linestyle=':')
  axes[0][0].axvline(0.75, color='black', linestyle=':')
  axes[0][0].axvline(1, color='black', linestyle=':')

  axes[0][0].set_xticks([0.0,0.5,1.0])
  #axes[0][0].set_yticks([])
  axes[0][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[0][0].set_ylabel( "L vs O")

  sns.kdeplot(MLP_overlap_L_O_1_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][0])

  xmedian1 = np.median(MLP_overlap_L_O_1_list)
  print(xmedian1)
  axes[0][0].axvline(xmedian1, color='red')





  axes[0][1].set_title( "MLP Top-3 Overlap",loc='center'  )

  axes[0][1].axvline(0, color='black', linestyle=':')
  axes[0][1].axvline(0.25, color='black', linestyle=':')
  axes[0][1].axvline(0.5, color='black', linestyle=':')
  axes[0][1].axvline(0.75, color='black', linestyle=':')
  axes[0][1].axvline(1, color='black', linestyle=':')

  axes[0][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][1].set_yticks([])

  sns.kdeplot(MLP_overlap_L_O_3_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][1])

  xmedian2 = np.median(MLP_overlap_L_O_3_list)
  print(xmedian2)
  axes[0][1].axvline(xmedian2, color='red')


  axes[0][2].set_title( "MLP Top-5 Overlap",loc='center'  )
  axes[0][2].axvline(0, color='black', linestyle=':')
  axes[0][2].axvline(0.25, color='black', linestyle=':')
  axes[0][2].axvline(0.5, color='black', linestyle=':')
  axes[0][2].axvline(0.75, color='black', linestyle=':')
  axes[0][2].axvline(1, color='black', linestyle=':')
  axes[0][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[0][2].set_yticks([])
  sns.kdeplot(MLP_overlap_L_O_5_list, shade=True, color='darkblue', linewidth=2, ax=axes[0][2])

  xmedian3 = np.median(MLP_overlap_L_O_5_list)
  print(xmedian3)
  axes[0][2].axvline(xmedian3, color='red')


  axes[1][0].axvline(0, color='black', linestyle=':')
  axes[1][0].axvline(0.25, color='black', linestyle=':')
  axes[1][0].axvline(0.5, color='black', linestyle=':')
  axes[1][0].axvline(0.75, color='black', linestyle=':')
  axes[1][0].axvline(1, color='black', linestyle=':')
  axes[1][0].set_xticks([0.0,0.5,1.0])
  axes[1][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[1][0].set_ylabel( "M vs O")

  sns.kdeplot(MLP_overlap_M_O_1_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][0])

  xmedian4 = np.median(MLP_overlap_M_O_1_list)
  print(xmedian4)
  axes[1][0].axvline(xmedian4, color='red')


  axes[1][1].axvline(0, color='black', linestyle=':')
  axes[1][1].axvline(0.25, color='black', linestyle=':')
  axes[1][1].axvline(0.5, color='black', linestyle=':')
  axes[1][1].axvline(0.75, color='black', linestyle=':')
  axes[1][1].axvline(1, color='black', linestyle=':')

  axes[1][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][1].set_yticks([])
  sns.kdeplot(MLP_overlap_M_O_3_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][1])

  xmedian5 = np.median(MLP_overlap_M_O_3_list)
  print(xmedian5)
  axes[1][1].axvline(xmedian5, color='red')


  axes[1][2].axvline(0, color='black', linestyle=':')
  axes[1][2].axvline(0.25, color='black', linestyle=':')
  axes[1][2].axvline(0.5, color='black', linestyle=':')
  axes[1][2].axvline(0.75, color='black', linestyle=':')
  axes[1][2].axvline(1, color='black', linestyle=':')
  axes[1][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[1][2].set_yticks([])
  sns.kdeplot(MLP_overlap_M_O_5_list, shade=True, color='darkorange', linewidth=2, ax=axes[1][2])

  xmedian6 = np.median(MLP_overlap_M_O_5_list)
  print(xmedian6)
  axes[1][2].axvline(xmedian6, color='red')


  axes[2][0].axvline(0, color='black', linestyle=':')
  axes[2][0].axvline(0.25, color='black', linestyle=':')
  axes[2][0].axvline(0.5, color='black', linestyle=':')
  axes[2][0].axvline(0.75, color='black', linestyle=':')
  axes[2][0].axvline(1, color='black', linestyle=':')
  axes[2][0].set_xticks([0.0,0.5,1.0])
  axes[2][0].yaxis.set_major_formatter(plt.NullFormatter())
  axes[2][0].set_ylabel( "Z vs O")

  sns.kdeplot(MLP_overlap_S_O_1_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][0])

  xmedian7 = np.median(MLP_overlap_S_O_1_list)
  print(xmedian7)
  axes[2][0].axvline(xmedian7, color='red')

  axes[2][1].axvline(0, color='black', linestyle=':')
  axes[2][1].axvline(0.25, color='black', linestyle=':')
  axes[2][1].axvline(0.5, color='black', linestyle=':')
  axes[2][1].axvline(0.75, color='black', linestyle=':')
  axes[2][1].axvline(1, color='black', linestyle=':')

  axes[2][1].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][1].set_yticks([])
  sns.kdeplot(MLP_overlap_S_O_3_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][1])

  xmedian8 = np.median(MLP_overlap_S_O_3_list)
  print(xmedian8)
  axes[2][1].axvline(xmedian8, color='red')

  axes[2][2].axvline(0, color='black', linestyle=':')
  axes[2][2].axvline(0.25, color='black', linestyle=':')
  axes[2][2].axvline(0.5, color='black', linestyle=':')
  axes[2][2].axvline(0.75, color='black', linestyle=':')
  axes[2][2].axvline(1, color='black', linestyle=':')
  axes[2][2].set_xticks([0.0,0.25,0.5,0.75,1.0])
  axes[2][2].set_yticks([])
  sns.kdeplot(MLP_overlap_S_O_5_list, shade=True, color='darkgreen', linewidth=2, ax=axes[2][2])
  xmedian9 = np.median(MLP_overlap_S_O_5_list)
  print(xmedian9)
  axes[2][2].axvline(xmedian9, color='red')

#作图统计 作图用原始的数据列表 论文里用分布图 数据分析时结合 概率分布图和概率值统计 分析 这个作为参考分析！！！！

import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt



with sns.axes_style('darkgrid'):
  fig, axes = plt.subplots(3, 3, figsize=(12, 6),sharey=True,sharex=True, dpi=350) # sharey=True ,sharex=True, dpi=350
  fig.subplots_adjust(wspace=0.010,hspace=0.050)



  axes[0][0].set_title( "Top-1 Overlap",loc='center'  )

  sns.histplot(data=MLP_overlap_L_O_1_list, kde=True, stat='probability',ax=axes[0][0])

  axes[0][1].set_title( "Top-3 Overlap",loc='center'  )

  sns.histplot(data=MLP_overlap_L_O_3_list, kde=True, stat='probability',ax=axes[0][1])

  axes[0][2].set_title( "Top-5 Overlap",loc='center'  )
  sns.histplot(data=MLP_overlap_L_O_5_list, kde=True, stat='probability',ax=axes[0][2])



  sns.histplot(data=MLP_overlap_M_O_1_list, kde=True, stat='probability',ax=axes[1][0])

  sns.histplot(data=MLP_overlap_M_O_3_list, kde=True, stat='probability',ax=axes[1][1])

  sns.histplot(data=MLP_overlap_M_O_5_list, kde=True, stat='probability',ax=axes[1][2])



  sns.histplot(data=MLP_overlap_S_O_1_list, kde=True, stat='probability',ax=axes[2][0])

  sns.histplot(data=MLP_overlap_S_O_3_list, kde=True, stat='probability',ax=axes[2][1])

  sns.histplot(data=MLP_overlap_S_O_5_list, kde=True, stat='probability',ax=axes[2][2])